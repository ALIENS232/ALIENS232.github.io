{"title":"数据结构","uid":"81579b6c641dedc829a2b0058112fc0c","slug":"数据结构","date":"2022-12-27T09:55:32.000Z","updated":"2022-12-27T09:59:32.231Z","comments":true,"path":"api/articles/数据结构.json","keywords":"博客","cover":[],"content":"<h1 id=\"基本数据结构（code）\"><a href=\"#基本数据结构（code）\" class=\"headerlink\" title=\"基本数据结构（code）\"></a>基本数据结构（code）</h1><h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><h3 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h3><h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><h3 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h3><h2 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h2><h3 id=\"一维：\"><a href=\"#一维：\" class=\"headerlink\" title=\"一维：\"></a>一维：</h3><h3 id=\"二维：\"><a href=\"#二维：\" class=\"headerlink\" title=\"二维：\"></a>二维：</h3><h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyHashSet &#123;\npublic:\n    MyHashSet() &#123;\n        this-&gt;bucket.resize(BUCKSIZE);\n    &#125;\n\n    int HashFunc(int key)&#123;\n        return key % this-&gt;M;\n    &#125;\n\n    void add(int key) &#123;\n        int loc &#x3D; HashFunc(key);\n        if(!this-&gt;Search4Key(key))&#123;\n            (this-&gt;bucket)[loc].push_back(key);\n        &#125;\n    &#125;\n    \n    void remove(int key) &#123;\n        int loc &#x3D; HashFunc(key);\n        if(this-&gt;Search4Key(key))&#123;\n            for(vector&lt;int&gt;::iterator it&#x3D;(this-&gt;bucket)[loc].begin(); \n                it!&#x3D;(this-&gt;bucket)[loc].end(); it++)&#123;\n                    if(*it &#x3D;&#x3D; key)&#123;\n                        this-&gt;bucket[loc].erase(it);\n                        break;\n                    &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    bool contains(int key) &#123;\n        return this-&gt;Search4Key(key);\n    &#125;\n\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; bucket;\n    const int M &#x3D; 1000;\n    const int BUCKSIZE &#x3D; 1000;\n\n    int BinarySearch(vector&lt;int&gt;&amp; v, int target)&#123;\n        sort(v.begin(), v.end());\n        int left &#x3D; 0, right &#x3D; v.size()-1;\n        int loc &#x3D; -1;\n\n        while(left &lt;&#x3D; right)&#123;\n            int mid &#x3D; (left + right) % 2 &#x3D;&#x3D; 0 ? (left + right) &#x2F; 2: (left + right) &#x2F; 2 + 1;\n            eif(v[mid] &#x3D;&#x3D; target)&#123;\n                loc &#x3D; mid;\n                break;\n            &#125;else if(v[mid] &lt; target)&#123;\n                left &#x3D; mid + 1;\n            &#125;else&#123;\n                right &#x3D; mid - 1;\n            &#125;\n        &#125;\n\n        return loc;\n    &#125;\n\n    bool Search4Key(int key)&#123;\n        bool canget &#x3D; false;\n        int loc &#x3D; HashFunc(key);\n        if( this-&gt;BinarySearch(bucket[loc], key) !&#x3D; -1 )&#123;\n            canget &#x3D; true;\n        &#125;\n\n        return canget;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj &#x3D; new MyHashSet();\n * obj-&gt;add(key);\n * obj-&gt;remove(key);\n * bool param_3 &#x3D; obj-&gt;contains(key);\n *&#x2F;\n</code></pre>\n\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"基本队列\"><a href=\"#基本队列\" class=\"headerlink\" title=\"基本队列\"></a>基本队列</h3><h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><h3 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h3><h3 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h3><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Stack\n&#123;\nprivate:\n\tT A[MaxSize];\n\tint top &#x3D; -1;\npublic:\n\tbool empty()\n\t&#123;\n\t\treturn top &#x3D;&#x3D; -1;\n\t&#125;\n\n\tbool full()\n\t&#123;\n\t\treturn top &#x3D;&#x3D; MaxSize - 1;\n\t&#125;\n\n\tvoid push(T item)\n\t&#123;\n\t\tA[++top] &#x3D; item;\n\t&#125;\n\n\tT pop()\n\t&#123;\n\t\treturn A[top--];\n\t&#125;\n\n\tT top()\n\t&#123;\n\t\treturn A[top];\n\t&#125;\n&#125;;</code></pre>\n\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;链栈\ntemplate&lt;typename T&gt;\nclass link_stack\n&#123;\n\npublic:\n\tclass stack_node\n\t&#123;\n\tpublic:\n\t\tstack_node*next;\n\t\tstack_node*pre;\n\t\tT val;\n\t\tstack_node(T val)\n\t\t&#123;\n\t\t\tnext &#x3D; nullptr;\n\t\t\tpre &#x3D; nullptr;\n\t\t\tthis-&gt;val &#x3D; val;\n\t\t&#125;\n\t&#125;;\nprivate:\n\tstack_node*top_ptr;\n\tint size &#x3D; 0;\npublic:\n\tlink_stack()\n\t&#123;\n\t\ttop_ptr &#x3D; nullptr;\n\t&#125;\n\n\tvoid push(T val)\n\t&#123;\n\t\tstack_node*new_node &#x3D; new stack_node(val);\n\t\tif (top_ptr)\n\t\t&#123;\n\t\t\ttop_ptr-&gt;next &#x3D; new_node;\n\t\t&#125;\n\t\tnew_node-&gt;pre &#x3D; top_ptr;\n\t\ttop_ptr &#x3D; new_node;\n\t&#125;\n\n\tT pop()\n\t&#123;\n\t\tif (empty())\n\t\t&#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\tT temp &#x3D; top_ptr-&gt;val;\n\t\tstack_node*to_del &#x3D; top_ptr;\n\t\ttop_ptr &#x3D; top_ptr-&gt;pre;\n\t\tdelete(to_del);\n\t\treturn temp;\n\t&#125;\n\n\tT top()\n\t&#123;\n\t\tif (empty())\n\t\t&#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn top_ptr-&gt;val;\n\t&#125;\n\n\tbool empty()\n\t&#123;\n\t\treturn top_ptr &#x3D;&#x3D; nullptr;\n\t&#125;\n\n&#125;;\n</code></pre>\n\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h4><h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template&lt;typename T&gt;\nclass Tree\n&#123;\npublic:\n\tclass TreeNode\n\t&#123;\n\tpublic:\n\t\tTreeNode*right;\n\t\tTreeNode*left;\n\t\tT val;\n\t\tTreeNode(T val)\n\t\t&#123;\n\t\t\tright &#x3D; nullptr;\n\t\t\tleft &#x3D; nullptr;\n\t\t\tthis-&gt;val &#x3D; val;\n\t\t&#125;\n\t&#125;;\npublic:\n\tTreeNode*root;\n\tT null_mark;\n\tint num &#x3D; 0;\n\tTree(T mark)\n\t&#123;\n\t\tnull_mark &#x3D; mark;\n\t\troot &#x3D; build();\n\t&#125;\n\n\tTreeNode* build()\n\t&#123;\n        cin&gt;&gt;num;\n\t\tif (num &#x3D;&#x3D; null_mark)\n\t\t&#123;\n\t\t\treturn nullptr;\n\t\t&#125;\n\n\n\t\tTreeNode*cur_node &#x3D; new TreeNode(num);\n\t\tcur_node-&gt;left &#x3D; build();\n\t\tcur_node-&gt;right &#x3D; build();\n\t\treturn cur_node;\n\t&#125;\n\n\tvoid forward_travel(TreeNode*root)\n\t&#123;\n\t\tlink_stack&lt;TreeNode*&gt;ls;\n\t\tTreeNode*node &#x3D; root;\n\t\twhile (true)\n\t\t&#123;\n\t\t\twhile (node !&#x3D; nullptr)\n\t\t\t&#123;\n                cout &lt;&lt; node-&gt;val&lt;&lt;&#39; &#39;;\n\t\t\t\tls.push(node);\n\t\t\t\tnode &#x3D; node-&gt;left;\n\t\t\t&#125;\n\t\t\tif (!ls.empty())\n\t\t\t&#123;\n\t\t\t\tnode &#x3D; ls.pop();\n\t\t\t\t\n\t\t\t\tnode &#x3D; node-&gt;right;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn;\n\t&#125;\n\n\tvoid midward_travel(TreeNode*root)\n\t&#123;\n\t\tlink_stack&lt;TreeNode*&gt;ls;\n\t\tTreeNode*node &#x3D; root;\n\t\twhile (true)\n\t\t&#123;\n\t\t\twhile (node !&#x3D; nullptr)\n\t\t\t&#123;\n\t\t\t\tls.push(node);\n\t\t\t\tnode &#x3D; node-&gt;left;\n\t\t\t&#125;\n\t\t\tif (!ls.empty())\n\t\t\t&#123;\n\t\t\t\tnode &#x3D; ls.pop();\n\t\t\t\tcout &lt;&lt; node-&gt;val&lt;&lt;&#39; &#39;;\n\t\t\t\tnode &#x3D; node-&gt;right;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn;\n\t&#125;\n\n\tvoid backward_travel(TreeNode*root)\n\t&#123;\n\t\tif (!root)\n\t\t&#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tbackward_travel(root-&gt;left);\n\t\tbackward_travel(root-&gt;right);\n\t\tcout &lt;&lt; root-&gt;val &lt;&lt; &#39; &#39;;\n\t\treturn;\n\t&#125;\n&#125;;</code></pre>\n\n<h3 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class HuffmanTree\n&#123;\npublic:\n\tclass Node\n\t&#123;\n\tpublic:\n\t\tchar data;\n\t\tint weight;\n\t\tNode*left;\n\t\tNode*right;\n\t\tNode()\n\t\t&#123;\n\t\t\tweight &#x3D; 0;\n\t\t\tdata &#x3D; 0;\n\t\t\tleft &#x3D; right &#x3D; nullptr;\n\t\t&#125;\n\t&#125;;\n\n\tint N;&#x2F;&#x2F;节点个数（不同的字符个数）\n\tchar*ch;\n\tint*freq;\n\tNode*H;\n\tint WPL&#x3D;0;\n\tNode*root;\n\n\tHuffmanTree()\n\t&#123;\n\t\tch &#x3D; new char[N];\n\t\tfreq &#x3D; new int[N];\n\t\tH &#x3D; new Node[N];\n\t\tfor (int i &#x3D; 0; i &lt; N; i++)\n\t\t&#123;\n\t\t\tH[i].data &#x3D; ch[i];\n\t\t\tH[i].weight &#x3D; freq[i];\n\t\t&#125;\n\t\t&#x2F;&#x2F;排序，未实现\n\t\tHsort();\n\n\t\tfor (int i &#x3D; 0; i &lt; N - 1; i++)\n\t\t&#123;\n\t\t\tNode*t &#x3D; new Node;\n\t\t\tt-&gt;weight &#x3D; H[i].weight + H[i + 1].weight;\n\t\t\tWPL+&#x3D; t-&gt;weight;\n\t\t\tt-&gt;left &#x3D; &amp;H[i];\n\t\t\tt-&gt;right &#x3D; &amp;H[i + 1];\n\t\t\tt-&gt;data &#x3D; &#39; &#39;;\n\t\t\tint j &#x3D; i + 2;\n\t\t\twhile (j&lt;N&amp;&amp;t-&gt;weight&gt;H[j].weight)\n\t\t\t&#123;\n\t\t\t\tH[j - 1] &#x3D; H[j];\n\t\t\t&#125;\n\t\t\tH[j - 1] &#x3D; *t;\n\t\t&#125;\n\t\troot &#x3D; &amp;H[N - 1];\n\t&#125;\n\n\n\tvoid Hsort()\n\t&#123;\n\n\t&#125;\n\n\t~HuffmanTree()\n\t&#123;\n\t\tdelete[]ch;\n\t\tdelete[]freq;\n\t\tdelete[]H;\n\t&#125;\n\n&#125;;</code></pre>\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nclass huffman\n&#123;\npublic:\n\tclass TreeNode\n\t&#123;\n\tpublic:\n\t\tchar ch&#x3D;&#39; &#39;;\n\t\tint weight;\n\t\tstring str&#x3D;&quot;&quot;;\n\t\tTreeNode*left;\n\t\tTreeNode*right;\n\t\tTreeNode(char c)\n\t\t&#123;\n\t\t\tleft &#x3D; right &#x3D; nullptr;\n\t\t\tch &#x3D; c;\n\t\t\tweight &#x3D; 0;\n\t\t&#125;\n\t&#125;;\n\n\t&#x2F;&#x2F;次数数组\n\tint times[26];\n\t&#x2F;&#x2F;节点数组\n\tTreeNode* node[26];\n\t&#x2F;&#x2F;输出用的数组\n\tstring out[26];\n\t&#x2F;&#x2F;标记数组\n\tbool mark[26];\n\tint mark_sequence[26];\n\tstring s;\n\thuffman()\n\t&#123;\n\t\tcin &gt;&gt; s;\n\n\t\tint length &#x3D; s.size();\n\t\t&#x2F;&#x2F;初始化\n\t\tmemset(times, 0, sizeof(times));\n\t\tmemset(node, 0, sizeof(node));\n\t\tmemset(mark, 0, sizeof(mark));\n\t\tmemset(mark_sequence, 0, sizeof(mark_sequence));\n\t\t&#x2F;&#x2F;统计次数\n\t\tint temp_index &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; length; i++)\n\t\t&#123;\n\t\t\ttimes[s[i] - &#39;a&#39;]++;\n\t\t\tif (mark[s[i]-&#39;a&#39;] &#x3D;&#x3D; 0)\n\t\t\t&#123;\n\t\t\t\tnode[temp_index] &#x3D; new TreeNode(s[i]);\n\t\t\t\tmark[s[i] - &#39;a&#39;] &#x3D; 1;\n\t\t\t\tmark_sequence[temp_index] &#x3D; s[i] - &#39;a&#39;;\n\t\t\t\ttemp_index++;\n\t\t\t&#125;\n\t\t&#125;\n\n\n\t\tmemset(mark, 0, sizeof(mark));\n\t\t&#x2F;&#x2F;tempindex就是出现的不同的字母的个数\n\t\tfor (int i &#x3D; 0; i &lt; temp_index; i++)\n\t\t&#123;\n\t\t\tnode[i]-&gt;weight &#x3D; times[node[i]-&gt;ch - &#39;a&#39;];\n\t\t&#125;\n\n\t\tfor (int i &#x3D; 0; i &lt; temp_index-1; i++)\n\t\t&#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; temp_index - i - 1; j++)\n\t\t\t&#123;\n\t\t\t\tif (node[i]-&gt;weight &gt; node[i + 1]-&gt;weight)\n\t\t\t\t&#123;\n\t\t\t\t\tTreeNode*temp &#x3D; node[i];\n\t\t\t\t\tnode[i] &#x3D; node[i + 1];\n\t\t\t\t\tnode[i + 1] &#x3D; temp;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tTreeNode*root&#x3D;CreatHuffanmanTree(temp_index);\n\n\t\tforward(root,&quot;&quot;);\n\n\t\tprint_code(temp_index);\n\n\t\tdecode(root);\n\t\tdecode(root);\n\t&#125;\n\n\tTreeNode*CreatHuffanmanTree(int num)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; num-1; i++)\n\t\t&#123;\n\t\t\tTreeNode*t &#x3D; new TreeNode(&#39;,&#39;);\n\t\t\tt-&gt;weight &#x3D; node[i]-&gt;weight + node[i + 1]-&gt;weight;\n\n\t\t\tt-&gt;left &#x3D; node[i];\n\t\t\tt-&gt;right &#x3D; node[i + 1];\n\t\t\tint j &#x3D; i + 2;\n\t\t\twhile (j&lt;num &amp;&amp; t-&gt;weight&gt;&#x3D;node[j]-&gt;weight) &#123;\n\t\t\t\tnode[j - 1] &#x3D; node[j]; j++;\n\t\t\t&#125;\n\t\t\tnode[j - 1] &#x3D; t;\n\t\t&#125;\n\t\treturn node[num - 1];\n\t&#125;\n\n\tvoid forward(TreeNode*root,string s)\n\t&#123;\n\t\tif (!root-&gt;left&amp;&amp;!root-&gt;right)\n\t\t&#123;\n\t\t\tout[root-&gt;ch - &#39;a&#39;] &#x3D;root-&gt;str ;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (root-&gt;left)\n\t\t&#123;\n\t\t\troot-&gt;left-&gt;str&#x3D;s+&#39;0&#39;;\n\t\t\tforward(root-&gt;left,root-&gt;left-&gt;str);\n\t\t&#125;\n\t\tif (root-&gt;right)\n\t\t&#123;\n\t\t\troot-&gt;right-&gt;str&#x3D;s+&#39;1&#39;;\n\t\t\tforward(root-&gt;right,root-&gt;right-&gt;str);\n\t\t&#125;\n\t&#125;\n\n\tvoid print_code(int num)\n\t&#123;\n\t\tint count &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; s.size(); i++)\n\t\t&#123;\n\t\t\tcount +&#x3D; out[s[i]-&#39;a&#39;].size();\n\t\t&#125;\n\t\tcount &#x3D; count % 8 &#x3D;&#x3D; 0 ? count &#x2F; 8 : count &#x2F; 8+1;\n\t\tcout &lt;&lt; s.size() &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl;\n\t\tfor (int i &#x3D; 0; i &lt; num; i++)\n\t\t&#123;\n\t\t\tchar ch &#x3D; mark_sequence[i] + &#39;a&#39;;\n\t\t\tcout &lt;&lt; ch &lt;&lt; &quot;:&quot; &lt;&lt; out[mark_sequence[i]] &lt;&lt; endl;\n\t\t\t\n\t\t&#125;\n\t&#125;\n\n\tvoid decode(TreeNode*root)\n\t&#123;\n\t\ts &#x3D; &quot;&quot;;\n\t\tstring ans;\n\n\t\tcin &gt;&gt; s;\n\n\t\tint code_length &#x3D; s.size();\n\t\tint code_index &#x3D; 0;\n\t\tbool flag &#x3D; true;\n\t\twhile (code_index &lt; code_length)\n\t\t&#123;\n\t\t\tTreeNode*node &#x3D; root;\n\t\t\twhile (node)\n\t\t\t&#123;\n\t\t\t\tif ((node-&gt;left || node-&gt;right) &amp;&amp; code_length &#x3D;&#x3D; code_index)\n\t\t\t\t&#123;\n\t\t\t\t\tcout &lt;&lt; &quot;INVALID&quot; &lt;&lt; endl;\n\t\t\t\t\tflag &#x3D; false;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tif (!node-&gt;left &amp;&amp; !node-&gt;right)\n\t\t\t\t&#123;\n\t\t\t\t\tans +&#x3D; node-&gt;ch;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tif (s[code_index] &#x3D;&#x3D; &#39;0&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tnode &#x3D; node-&gt;left;\n\t\t\t\t\tcode_index++;\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\tnode &#x3D; node-&gt;right;\n\t\t\t\t\tcode_index++;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (flag)\n\t\t&#123;\n\t\t\tcout &lt;&lt; ans;\n\t\t&#125;\n\n\n\t&#125;\n\n&#125;;\n\nint main()\n&#123;\n\thuffman hf;\n\treturn 0;\n&#125;</code></pre>\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass Tree\n&#123;\npublic:\n\tclass TreeNode\n\t&#123;\n\tpublic:\n\t\tTreeNode*right;\n\t\tTreeNode*left;\n\t\tT val;\n\t\tTreeNode(T val)\n\t\t&#123;\n\t\t\tright &#x3D; nullptr;\n\t\t\tleft &#x3D; nullptr;\n\t\t\tthis-&gt;val &#x3D; val;\n\t\t&#125;\n\t&#125;;\npublic:\n\tTreeNode*root;\n\tT null_mark;\n    TreeNode* parent&#x3D;nullptr;\n\tint num &#x3D; 0;\n\tTree(T mark)\n\t&#123;\n\t\tnull_mark &#x3D; mark;\n\t\troot &#x3D; build();\n\t&#125;\n\n\tTreeNode* build()\n\t&#123;\n        cin&gt;&gt;num;\n\t\tif (num &#x3D;&#x3D; null_mark)\n\t\t&#123;\n\t\t\treturn nullptr;\n\t\t&#125;\n\n\n\t\tTreeNode*cur_node &#x3D; new TreeNode(num);\n\t\tcur_node-&gt;left &#x3D; build();\n\t\tcur_node-&gt;right &#x3D; build();\n\t\treturn cur_node;\n\t&#125;\n    \n\tTreeNode* find(TreeNode*cur_node,T target)\n\t&#123;\n\t\tif(cur_node&#x3D;&#x3D;nullptr||cur_node-&gt;val&#x3D;&#x3D;target)return nullptr;\n        if(cur_node-&gt;left-&gt;val&#x3D;&#x3D;target||cur_node-&gt;right-&gt;val&#x3D;&#x3D;target)\n        &#123;\n            return cur_node;\n        &#125;\n        TreeNode*fa&#x3D;find(cur_node-&gt;left,target);\n        if(fa!&#x3D;nullptr)return fa;\n        return find(cur_node-&gt;right,target);\n\t&#125;\n\t\n&#125;;\n\nint main()\n&#123;\n\tint mark &#x3D; 0;\n\tTree&lt;int&gt; t(mark);\n    int ops&#x3D;0;\n    int num&#x3D;0;\n    cin&gt;&gt;ops;\n\tfor(int i&#x3D;0;i&lt;ops;i++)\n    &#123;\n        cin&gt;&gt;num;\n        t.parent&#x3D;t.find(t.root,num);\n        if(!t.parent)\n        &#123;\n            cout&lt;&lt;0&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;t.parent-&gt;val&lt;&lt;endl;\n        &#125;\n        t.parent&#x3D;nullptr;\n    &#125;\n\treturn 0;\n&#125;</code></pre>\n\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;string.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n&#123;\npublic:\n\tint*next;\n\tchar pattern[100500];\n    char target[100500];\n    int len1&#x3D;0;\n    int len2&#x3D;0;\n\tvoid init()\n\t&#123;\n\t\tscanf(&quot;%s&quot;,&amp;target);\n        getchar();\n        scanf(&quot;%s&quot;,&amp;pattern);\n        getchar();\n        len1&#x3D;strlen(target);\n        len2&#x3D;strlen(pattern);\n\t\tcout&lt;&lt;Strstr();\n\t&#125;\n\n\tvoid buildnext()\n\t&#123;\n\t\tint len &#x3D; len2;\n\t\tnext &#x3D; new int[len];\n\t\tnext[0] &#x3D; -1;\n\t\tint k &#x3D; -1;\n\t\tfor (int i &#x3D; 0; i &lt; len - 1; i++)\n\t\t&#123;\n\t\t\twhile (k &gt;&#x3D; 0 &amp;&amp; pattern[i] !&#x3D; pattern[k])k &#x3D; next[k];\n\t\t\tnext[i + 1] &#x3D; ++k;\n\t\t&#125;\n\t\tcout &lt;&lt; next[len &#x2F; 4] &lt;&lt; &#39; &#39;;\n\t\tcout &lt;&lt; next[len &#x2F; 2] &lt;&lt; &#39; &#39;;\n\t\tcout &lt;&lt; next[3 * len &#x2F; 4] &lt;&lt; &#39; &#39; &lt;&lt; endl;\n\t&#125;\n\n\tint Strstr()\n\t&#123;\n\t\tbuildnext();\n\t\tint m &#x3D; len1;\n\t\tint n &#x3D; len2;\n\t\tint i &#x3D; 0;\n\t\tint j &#x3D; 0;\n\t\twhile (i &lt; m&amp;&amp;j &lt; n)\n\t\t&#123;\n\t\t\tif (j &#x3D;&#x3D; -1 || target[i] &#x3D;&#x3D; pattern[j])\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tj &#x3D; next[j];\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (j &#x3D;&#x3D; n)return i - j;\n\t\treturn -1;\n\t&#125;\n\n\t~Solution()\n\t&#123;\n\t\tdelete[]next;\n\t&#125;\n&#125;;</code></pre>\n\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><h3 id=\"图的存储结构与遍历\"><a href=\"#图的存储结构与遍历\" class=\"headerlink\" title=\"图的存储结构与遍历\"></a>图的存储结构与遍历</h3><h4 id=\"一些基本概念\"><a href=\"#一些基本概念\" class=\"headerlink\" title=\"一些基本概念\"></a>一些基本概念</h4><p>图G由两个集合V和E组成，记为G &#x3D; (V , E)；其中 V 是 顶点的有穷非空集合，E 是连接 V 中两个不同顶点的边的有 穷集合。通常，也将图G的顶点集和边集分别记为V(G)和E(G)。</p>\n<p>若图中的边限定为从一个顶点指向另一个顶点，则称此图为 有向图。 若图中的边无方向性，则称之为无向图。</p>\n<p>若G &#x3D; (V, E)是有向图，则它的一条有向边是由V中两个 顶点构成的有序对，亦称为弧，记为，其中w是边的始 点，又称弧尾； v是边的终点，又称弧头。</p>\n<p>在一个无向图中，若存在一条边(w, v)，则称w, v为此边 的两个端点，它们是相邻的，并称它们互为邻接顶点。 在一个有向图中，若存在一条边，则称顶点w邻接到顶 点v，顶点v邻接自顶点w。</p>\n<p>由于E是边的集合，故一个图中不会多次出现一条边。 若去掉此限制，则由此产生的结构称为多重图。图 (c)就是一 个多重图。</p>\n<p>设G是无向图，vV(G)，E(G)中以v为端点的边的个 数，称为顶点v的度。</p>\n<p>若G是有向图，则v的出度是以v为始点的边的个数，v 的入度是以v为终点的边的个数 ，顶点的度&#x3D;入度+出 度。</p>\n<p>度数&#x3D;2e</p>\n<p>设G是图，若存在一个顶点序列 使得 或 属于E(G)， 则称vp到vq存在一条路径，其中vp 称为起点，vq称为终点。 路径的长度是该路径上边的个数。  如果一条路径上除了起点和终点可以相同外，再不能有相同 的顶点，则称此路径为简单路径。 如果一条简单路径的起点和终点相同，且路径长度大于等于 2，则称之为简单回路。</p>\n<p>欧拉回路（一笔画） 每条边经过一次</p>\n<p>汉密尔顿回路 每个顶点经过一次</p>\n<p>设G，H是图，如果V(H) 包含于 V(G)，E(H) 包含于 E(G)， 则称H是G的子图，G是H的母图。如果H是G的子图， 并且V(H) &#x3D; V(G)，则称H为G的支撑子图。</p>\n<p>设G是图，若存在一条从顶点vi到顶点vj的路径， 则称vi与vj可及（连通）。 若G为无向图，且V(G)中任意两顶点都可及，则称G 为连通图。 若G为有向图，且对于V(G)中任意两个不同的顶点vi 和vj ， vi与vj可及， vj与vi也可及，则称G为强连通图</p>\n<p>设图G &#x3D; (V，E)是无向图，若G的子图GK是一个连通 图，则称GK为G的连通子图；G的极大连通子图称为 G的连通分量 。 设图G &#x3D; (V，E)是有向图，若G的子图GK是一个强连 通图，则称GK 为G的强连通子图；G的极大强连通子 图称为G的强连通分量 。</p>\n<p>权图，权重</p>\n<p>无向图 有向图 无向边 有向边（弧） 端点 弧头 弧尾 相邻的 邻接到 邻接自 度 出度 入度 连通图 强连通图 连通子图 强连通子图 连通分量 强连通分量</p>\n<h4 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h4><h5 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h5><p>用顺序方式存储图的顶点表v0 ,v1 ,…vn−1，图的边用 n*n 阶矩阵 A&#x3D;(aij) 表示，A 的定义如下: </p>\n<p>⑴若非权图，则: </p>\n<p>➢aii &#x3D; 0； </p>\n<p>➢aij &#x3D; 1，当 i ≠ j 且 vi 与vj之间存在边； </p>\n<p>➢aij &#x3D; 0，当 i 不等于 j 且 vi 与vj之间不存在边。 </p>\n<p>⑵若权图，则: </p>\n<p>➢aii &#x3D; 0； </p>\n<p>➢aij &#x3D; 边的权值，当 i ≠ j 且 vi 与vj之间存在边； </p>\n<p>➢aij &#x3D; 正无穷，当 i ≠ j 且 vi 与vj之间不存在边。</p>\n<p>借助邻接矩阵可方便的求出图中顶点的度 </p>\n<p>无向无权图 矩阵的第i行（或第i列）的1的个数是顶点Vi的度。</p>\n<p>有向无权图 邻接矩阵第i行的1的个数为顶点Vi的出度 第i列的1的个数为顶点Vi的入度。</p>\n<h5 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h5><p>➢ 顺序存储顶点表。 </p>\n<p>➢ 对图的每个顶点建立一个单链表，第 i 个单链表中的结点包 含顶点vi的所有邻接顶点（边链表）。 </p>\n<p>➢ 由顺序存储的顶点表和链接存储的边链表构成的图存储结构 被称为邻接表。</p>\n<p>➢与顶点 v 邻接的所有顶点以某种次序组成的单链表称为顶点 v 的边链表。</p>\n<p> ➢边链表的每一个结点叫做边结点，对于非权图和权图边结点 结构分别为: 其中, 域VerAdj存放 v 的某个邻接顶点在顶点表中的下标；域 link存放指向 v 的边链表中结点 VerAdj 的下一个结点的指针。 域cost 存放边(v, VerAdj)或的权值；</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Vertex&#123; &#x2F;&#x2F;顶点表中结点的结构\n\tint VerName; &#x2F;&#x2F;顶点名称\n\tEdge *adjacent;&#x2F;&#x2F;边链表的头指针\n&#125;;\n\nstruct Edge&#123; &#x2F;&#x2F;边结点的结构\n\tint VerAdj; &#x2F;&#x2F;邻接顶点序号\n\tint cost; &#x2F;&#x2F;边的权值\n\tEdge *link; &#x2F;&#x2F;指向下一个边结点的指针\n&#125;;</code></pre>\n\n<p>有向图：边结点的个数 &#x3D; e， e为图中边的条数</p>\n<p>无向图：边结点的个数&#x3D;2e， e为图中边的条数</p>\n<p>边结点的个数&#x3D;2e e为图中边的条数，但是，如果要统计一个顶点的入度，就要遍历所有的边结点， 其时间复杂度为O(e)（e为图中边的个数）， 从而统计所有顶点入度的时间复杂度为O(ne)（n为图的顶点 个数），对有向图建立逆邻接表（顶点 的指向关系与邻接表恰好相反 ），根据逆邻接表，很容易统 计出图中每个顶点的入度。</p>\n<p>采用邻接矩阵还是用邻接表来存储图，要视对给定图实施的 具体操作。 对边很多的图（也称稠密图），适于用邻接矩阵存储，因占 用的空间少。另一好处是可以将图中很多运算转换成矩阵运 算，方便计算。 对顶点多边少的图（也称稀疏图，如微信有几亿用户，每个 用户好友一般三五百个），若用邻接矩阵存储，对应的邻接 矩阵将是一个稀疏矩阵，存储利用率很低。因此，顶点多而 边少的图适于用邻接表存储。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass edge\n&#123;\npublic:\n\tint val;\n\tint weight;\n\tedge*link;\n\tedge(int val, int weight)\n\t&#123;\n\t\tthis-&gt;val &#x3D; val;\n\t\tlink &#x3D; nullptr;\n\t\tthis-&gt;weight &#x3D; weight;\n\t&#125;\n&#125;;\n\nclass Vertex\n&#123;\npublic:\n\tint val;\n\tedge*adjacent;\n\tVertex(int val)\n\t&#123;\n\t\tthis-&gt;val &#x3D; val;\n\t\tadjacent &#x3D; nullptr;\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tint node_num &#x3D; 0;\n\tcin &gt;&gt; node_num;\n\tint edge_num &#x3D; 0;\n\tcin &gt;&gt; edge_num;\n\tVertex*store[20100];\n\t&#x2F;&#x2F;初始化\n\tfor (int i &#x3D; 0; i &lt; node_num; i++)\n\t&#123;\n\t\tstore[i] &#x3D; new Vertex(i);\n\t&#125;\n\t&#x2F;&#x2F;输入边\n\tfor (int i &#x3D; 0; i &lt; edge_num; i++)\n\t&#123;\n\t\tint val &#x3D; 0;\n\t\tcin &gt;&gt; val;\n\t\tint next &#x3D; 0;\n\t\tcin &gt;&gt; next;\n\t\tint weight &#x3D; 0;\n\t\tcin &gt;&gt; weight;\n\t\tedge*new_edge &#x3D; new edge(next,weight);\n\t\tif (!store[val]-&gt;adjacent)\n\t\t&#123;\n\t\t\tstore[val]-&gt;adjacent &#x3D; new_edge;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\t\n\t\t\tif (next &lt; store[val]-&gt;adjacent-&gt;val)\n\t\t\t&#123;\n\t\t\t\tedge*temp &#x3D; store[val]-&gt;adjacent;\n\t\t\t\tstore[val]-&gt;adjacent&#x3D;new_edge ;\n\t\t\t\tnew_edge-&gt;link &#x3D; temp;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tedge*ptr &#x3D; store[val]-&gt;adjacent;\n\t\t\t\twhile (ptr-&gt;link&amp;&amp;next &gt;&#x3D; ptr-&gt;link-&gt;val)\n\t\t\t\t&#123;\n\t\t\t\t\tptr &#x3D; ptr-&gt;link;\n\t\t\t\t&#125;\n\t\t\t\tedge*temp &#x3D; ptr-&gt;link;\n\t\t\t\tptr-&gt;link &#x3D; new_edge;\n\t\t\t\tnew_edge-&gt;link &#x3D; temp;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;删除边\n\tint ops &#x3D; 0;\n\tcin &gt;&gt; ops;\n\tfor (int i &#x3D; 0; i &lt; ops; i++)\n\t&#123;\n\t\tint node &#x3D; 0;\n\t\tcin &gt;&gt; node;\n\t\tint next &#x3D; 0;\n\t\tcin &gt;&gt; next;\n\t\tedge*ptr &#x3D; store[node]-&gt;adjacent;\n\t\tif (ptr-&gt;val &#x3D;&#x3D; next)\n\t\t&#123;\n\t\t\tedge*temp &#x3D; ptr-&gt;link;\n\t\t\tstore[node]-&gt;adjacent &#x3D; temp;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\twhile (ptr-&gt;link&amp;&amp;ptr-&gt;link-&gt;val !&#x3D; next)\n\t\t\t&#123;\n\t\t\t\tptr &#x3D; ptr-&gt;link;\n\t\t\t&#125;\n\t\t\tedge*temp &#x3D; ptr-&gt;link-&gt;link;\n\t\t\tptr-&gt;link &#x3D; temp;\n\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;输出边\n\tfor (int i &#x3D; 0; i &lt; edge_num; i++)\n\t&#123;\n\t\tif (!store[i]||!store[i]-&gt;adjacent)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tcout &lt;&lt; store[i]-&gt;val &lt;&lt; &quot;:&quot;;\n\n\t\tedge*e &#x3D; store[i]-&gt;adjacent;\n\t\twhile (e)\n\t\t&#123;\n\t\t\tprintf(&quot;(%d,%d,%d)&quot;, store[i]-&gt;val, e-&gt;val, e-&gt;weight);\n\n\t\t\te &#x3D; e-&gt;link;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n\n<h4 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h4><p>图中可能存在回路，且图的任一顶点都可能与其它顶点连通， 在访问完某个顶点之后可能会沿着某些边又回到了曾经访问 过的顶点。 ➢ 为了避免重复访问，可用一个辅助数组vis[ ]记录顶点是否被 访问过，数组各元素初始值为0。在遍历过程中，一旦某一 个顶点 i被访问，就置 vis[i] 为 1。</p>\n<h5 id=\"深度优先遍历-x2F-搜索-DFS-Depth-First-Search-DFS\"><a href=\"#深度优先遍历-x2F-搜索-DFS-Depth-First-Search-DFS\" class=\"headerlink\" title=\"深度优先遍历&#x2F;搜索 DFS ( Depth First Search, DFS)\"></a>深度优先遍历&#x2F;搜索 DFS ( Depth First Search, DFS)</h5><p>递归算法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void DFS(Vertex*Head, int v, int vis[])&#123; &#x2F;&#x2F;vis初值为0\n\t&#x2F;&#x2F;以v为起点进行深度优先搜索\n\tprintf(“%d ”,v); vis[v]&#x3D;1; &#x2F;&#x2F;访问顶点v\n\tEdge* p&#x3D; Head[v].adjacent; &#x2F;&#x2F;考察v的所有邻接顶点\n\twhile(p!&#x3D;NULL)\n    &#123;\n\t\tif(vis[p-&gt;VerAdj]&#x3D;&#x3D;0) &#x2F;&#x2F;p未被访问\n\t\t\tDFS(Head,p-&gt;VerAdj,vis); &#x2F;&#x2F;以p为起点继续深搜\n\t\tp&#x3D;p-&gt;link;\n\t&#125;\n&#125;\n\nfor(int i&#x3D;0;i&lt;n;i++)\n&#123;\n\tif(vis[i]&#x3D;&#x3D;0)\n\tDFS(Head, i, vis);\n&#125;</code></pre>\n\n<p>非递归算法：</p>\n<p>① 将所有顶点的vis[ ]值置为0, 初始顶点v0入栈；</p>\n<p>② 检测栈是否为空，若栈为空，则算法结束； </p>\n<p>③ 从栈顶弹出一个顶点v，如果v未被访问过则： 访问v，并将vis[v]值更新为1； 将v的未被访问的邻接顶点入栈； </p>\n<p>④ 执行步骤 ② 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n<h5 id=\"广度优先遍历\"><a href=\"#广度优先遍历\" class=\"headerlink\" title=\"广度优先遍历\"></a>广度优先遍历</h5><p>邻接表</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void BFS(Vertex* Head, int v, int n, int vis[])\n\tQueue Q; &#x2F;&#x2F;创建队列Q，队列需预先实现\n\tfor(int i&#x3D;0; i&lt;n; i++) vis[i]&#x3D;0;\n\tprintf(“%d ”,v); vis[v]&#x3D;1;&#x2F;&#x2F;访问点v\n\tQ.Enqueue(v); &#x2F;&#x2F;起点v入队\n\twhile(!Q.Empty())\n    &#123;\n\t\tv&#x3D;Q.Dequeue(); &#x2F;&#x2F;出队一个点\n\t\tfor(Edge* p&#x3D;Head[v].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)\n\t\t\tif(vis[p-&gt;VerAdj]&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;考察v的邻接顶点p\n\t\t\t\tprintf(“%d ”, p-&gt;VerAdj);\n\t\t\t\tvis[p-&gt;VerAdj] &#x3D; 1;\n\t\t\t\tQ.Enqueue(p-&gt;VerAdj);\n\t\t\t&#125; &#x2F;&#x2F;end if\n\t&#125; &#x2F;&#x2F;end while\n&#125; &#x2F;&#x2F;end BFS</code></pre>\n\n<p>邻接矩阵</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void BFS(int** A, int v, int n, int vis[])&#x2F;&#x2F;邻接矩阵存图\n\tQueue Q; &#x2F;&#x2F;创建队列Q\n\tfor(int i&#x3D;0; i&lt;n; i++) vis[i]&#x3D;0;\n\tprintf(“%d ”,v); vis[v]&#x3D;1;&#x2F;&#x2F;访问点v\n\tQ.Enqueue(v); &#x2F;&#x2F;起点v入队\n\twhile(!Q.Empty())&#123;\n\t\tv&#x3D;Q.Dequeue(); &#x2F;&#x2F;出队一个点\n\t\tfor(int i&#x3D;0; i&lt;n; i++)\n\t\t\tif(A[v][i]&#x3D;&#x3D;1 &amp;&amp; vis[i]&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;考察v的邻接顶点\n\t\t\t\tprintf(“%d ”, i);\n\t\t\t\tvis[i] &#x3D; 1;\n\t\t\t\tQ.Enqueue(i);\n\t\t\t&#125; &#x2F;&#x2F;end if\n\t&#125; &#x2F;&#x2F;end while\n&#125; &#x2F;&#x2F;end BFS</code></pre>\n\n<h5 id=\"图遍历的应用举例\"><a href=\"#图遍历的应用举例\" class=\"headerlink\" title=\"图遍历的应用举例\"></a>图遍历的应用举例</h5><p>判断无向图是否连通及连通分量数目：</p>\n<p>方案1：DFS </p>\n<p>方案2：并查集</p>\n<p>判断图中顶点u到v是否存在路径：</p>\n<p>以u为起点遍历，看遍历过程中是否经过v</p>\n<p>判断无向图中是否有环：</p>\n<p>1，深度优先遍历，遍历过程中遇到之前访问过的顶点（不能 是当前访问点的前驱），即有环</p>\n<p>2，并查集（连通关系等价于等价关系）</p>\n<p>判断有向图中是否有环：</p>\n<p>在深度优先遍历过程中，一个顶点会经历3种状态：</p>\n<p>➢ vis[i]&#x3D;0，顶点i尚未被遍历到。 </p>\n<p>➢ vis[i]&#x3D;1，顶点i已经被遍历到，但对于它的遍历尚未结束。 该顶点还有若干邻接顶点尚未遍历，当前算法正在递归地深 入探索该顶点的某一邻接顶点。顶点i在当前探索的路径上。 </p>\n<p>➢ vis[i]&#x3D;2，顶点i的所有邻接顶点已完成遍历，其自身的遍历 也已结束。</p>\n<p>有环：DFS过程中遇到已访问过的且vis值为1的点</p>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><h4 id=\"关键概念\"><a href=\"#关键概念\" class=\"headerlink\" title=\"关键概念\"></a>关键概念</h4><p>AOV网；</p>\n<p>拓扑序列；</p>\n<h4 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h4><p>没有有向环</p>\n<p>拓扑序列未必唯一 </p>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>从图中选择一个入度为0的顶点并输出。</p>\n<p>从图中删除该顶点及该顶点引出的所有边。</p>\n<p>执行前两步，直至所有顶点已输出，或图中剩余顶点 入度均不为0（说明存在环，无法继续拓扑排序）。</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>建立一个数组count[ ]，count[i]为顶点i的入度；</p>\n<p>建立一个栈，存放入度为0的顶点，每当一个顶点的 入度为0，就将其压栈。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\"></code></pre>\n\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><h3 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h3><h4 id=\"关键概念-1\"><a href=\"#关键概念-1\" class=\"headerlink\" title=\"关键概念\"></a>关键概念</h4><p> AOE网:</p>\n<p>有向边表示活动或任务(Activity) </p>\n<p>边上的权值表示活动的持续时间</p>\n<p>顶点称为事件： 表示其入边的任务已完成，出边的任务可开始的状态。</p>\n<p> 源点：表示整个工程的开始(入度为0)</p>\n<p>汇点：表示整个工程的结束(出度为0)</p>\n<p>关键路径：从源点到汇点的最长路径称。</p>\n<p>关键活动：关键路径上的活动。</p>\n<p>事件 vj的最早发生时间 ve(j) ：从源点 v1 到 vj 的最长路径的长度</p>\n<p>事件 vj的最迟发生时间vl(j) ：等于ve(n)减去 vj 到 vn 的最长路径长度</p>\n<p>活动 ai 的最早开始时间 e(i) :e(i) &#x3D; ve( j),j为起始点</p>\n<p>活动 ai的最迟开始时间l(i)：l(i) &#x3D; vl(k)-weight(&lt;j,k&gt;)，j为起点，k为终点</p>\n<h4 id=\"求关键路径算法\"><a href=\"#求关键路径算法\" class=\"headerlink\" title=\"求关键路径算法\"></a>求关键路径算法</h4><p> 对AOE网进行拓扑排序，按顶点拓扑序求各顶点vj的最早 发生时间 ve(j)； </p>\n<p>按顶点的逆拓扑序求各顶点 vj的最迟发生时间vl(j)； </p>\n<p>根据各顶点ve和vl值，求出各活动 ai 的最早开始时间 e(i) 和最迟开始时间l(i)，若 e(i)&#x3D; l(i)，则ai是关键活动。</p>\n<h5 id=\"计算最短时间\"><a href=\"#计算最短时间\" class=\"headerlink\" title=\"计算最短时间\"></a>计算最短时间</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;ve用来存储所有节点的最长路径长度值\nvoid VertexEarliestTime(Vertex Head[],int n, int ve[])&#123;\n&#x2F;&#x2F;计算顶点的最早发生时间\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)ve[i]&#x3D;0;&#x2F;&#x2F;初始化\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++) &#x2F;&#x2F;按拓扑序计算各顶点最早发生时间，i是拓扑排序的顺序的下标\n\t\tfor(Edge* p&#x3D;Head[i].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;&#x2F;&#x2F;链接存储遍历链表内所有节点\n\t\t\tint k&#x3D;p-&gt;VerAdj;&#x2F;&#x2F;k是节点的下标\n\t\t\tif(ve[i]+p-&gt;cost&gt;ve[k])&#x2F;&#x2F;更新更大值\n\t\t\tve[k]&#x3D;ve[i]+p-&gt;cost;\n\t\t&#125;\n&#125;\n\n&#x2F;&#x2F;没有按拓扑排序顺序编号需要预处理排序形成拓扑数组\nvoid VertexEarliestTime(Vertex Head[],int Topo[],int n,int ve[])&#123;\n&#x2F;&#x2F;拓扑序存储在Topo数组中\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)ve[i]&#x3D;0;\n\t\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n\t\t&#x2F;&#x2F;按拓扑序计算各顶点最早发生时间\n\t\t\tEdge* p&#x3D;Head[Topo[i]].adjacent;\n\t\t\twhile(p!&#x3D;NULL)&#123;\n\t\t\t\tint k&#x3D;p-&gt;VerAdj;\n\t\t\t\tif(ve[Topo[i]]+p-&gt;cost&gt;ve[k])\n\t\t\t\tve[k]&#x3D;ve[Topo[i]]+p-&gt;cost;\n\t\t\t\tp&#x3D;p-&gt;link;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n&#x2F;&#x2F;拓扑排序时更新\nvoid TopoOrder(Vertex Head[], int n)&#123;\n\tint count[N]; Stack s;\n\tInDegree(Head, n, count); &#x2F;&#x2F;求每个顶点的入度\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) if(count[i]&#x3D;&#x3D;0) s.PUSH(i);\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n\t\t\tif(s.IsEmpty()) return;\n\t\t\tint j&#x3D;s.POP(); &#x2F;&#x2F;选出1个入度为0的顶点输出\n\t\t\t\tfor(Edge *p&#x3D;Head[j].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;\n\t\t\t\t\t&#x2F;&#x2F;删除j和j引出的边，其效果是j的邻接顶点的入度减1\n\t\t\t\t\tint k&#x3D;p-&gt;VerAdj; count[k]--; \n\t\t\t\t\tif(count[k]&#x3D;&#x3D;0) s.PUSH(k);\n                    &#x2F;&#x2F;多一步更新\n\t\t\t\t\tif(ve[k]+p-&gt;cost&gt;ve[k]) ve[k]&#x3D;ve[k]+p-&gt;cost;\n\t\t\t\t&#125;\n\t\t&#125;\n&#125;</code></pre>\n\n<h5 id=\"计算最迟发生时间\"><a href=\"#计算最迟发生时间\" class=\"headerlink\" title=\"计算最迟发生时间\"></a>计算最迟发生时间</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void VertexLatestTime(Vertex* Head,int n,int ve[],int vl[])&#123;\n\t&#x2F;&#x2F;计算顶点的最迟发生时间\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\tvl[i]&#x3D;ve[n];\n\t\tfor(int i&#x3D;n;i&gt;&#x3D;1;i--)&#123; &#x2F;&#x2F;按拓扑逆序计算各顶点最迟发生时间\n\t\t\tfor(Edge* p&#x3D;Head[i].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;\n\t\t\t\tint k&#x3D;p-&gt;VerAdj;\n\t\t\t\tif(vl[k]-p-&gt;cost &lt; vl[i])\n\t\t\t\tvl[i] &#x3D; vl[k]-p-&gt;cost;\n\t&#125;\n&#125;\n    \nvoid VertexLatestTime(Vertex *Head,int n, int Topo[],int ve[],int vl[])&#123;\n&#x2F;&#x2F;计算顶点的最迟发生时间\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)vl[i]&#x3D;ve[n];\n\t\tfor(int i&#x3D;n;i&gt;&#x3D;1;i--)&#123; &#x2F;&#x2F;按拓扑逆序计算各顶点最迟发生时间\n\t\t\tfor(Edge* p&#x3D;Head[Topo[i]].adjacent; p; p&#x3D;p-&gt;link)&#123;\n\t\t\t\tint k&#x3D;p-&gt;VerAdj;\n\t\t\t\tif(vl[k]-p-&gt;cost &lt; vl[Topo[i]])\n\t\t\t\tvl[Topo[i]] &#x3D; vl[k]-p-&gt;cost;\n\t\t\t&#125;\n\t\t&#125;\n&#125;</code></pre>\n\n<h5 id=\"求关键活动\"><a href=\"#求关键活动\" class=\"headerlink\" title=\"求关键活动\"></a>求关键活动</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void ActivityStartTime(Vertex* Head,int n,int ve[],int vl[])&#123;\n&#x2F;&#x2F;求诸活动的最早开始时间和最迟开始时间,并求关键活动\n\tfor(int i &#x3D; 1;i&lt;&#x3D;n;i++)&#123;\n\t\tfor(Edge* p&#x3D;Head[i].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;\n\t\t\tint k &#x3D; p-&gt;VerAdj;\n\t\t\tint e &#x3D; ve[i];\n\t\t\tint l &#x3D; vl[k] – p-&gt;cost;\n\t\t\tif(e &#x3D;&#x3D; l) printf(“%d-&gt;%d\\n”,i,k); &#x2F;&#x2F;输出关键活动\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h4 id=\"主函数\"><a href=\"#主函数\" class=\"headerlink\" title=\"主函数\"></a>主函数</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int N&#x3D;1010;\nvoid CriticalPath(Vertex* Head, int n)&#123;\n\t&#x2F;&#x2F;假定图中顶点已按拓扑序编号\n\tint ve[N],vl[N];\nVertexEarliestTime(Head,n,ve); &#x2F;&#x2F;顶点最早发生时间\nVertexLatestTime(Head,n,ve,vl); &#x2F;&#x2F;顶点最迟发生时间\nActivityStartTime(Head,n,ve,vl);&#x2F;&#x2F;活动最早最晚开始时间\n&#125;\n</code></pre>\n\n\n\n<h3 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h3><h4 id=\"无权图：广度优先遍历\"><a href=\"#无权图：广度优先遍历\" class=\"headerlink\" title=\"无权图：广度优先遍历\"></a>无权图：广度优先遍历</h4><h4 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra\"></a>Dijkstra</h4><p>lc：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt; &amp;times, int n, int k) &#123;\n        const int inf &#x3D; INT_MAX &#x2F; 2;\n\n        &#x2F;&#x2F; 邻接矩阵存储边信息\n        vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, inf));\n        for (auto &amp;t : times) &#123;\n            &#x2F;&#x2F; 边序号从 0 开始\n            int x &#x3D; t[0] - 1, y &#x3D; t[1] - 1;\n            g[x][y] &#x3D; t[2];\n        &#125;\n\n        &#x2F;&#x2F; 从源点到某点的距离数组\n        vector&lt;int&gt; dist(n, inf);\n        &#x2F;&#x2F; 由于从 k 开始，所以该点距离设为 0，也即源点\n        dist[k - 1] &#x3D; 0;\n\n        &#x2F;&#x2F; 节点是否被更新数组\n        vector&lt;bool&gt; used(n);\n\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点\n            int x &#x3D; -1;\n            for (int y &#x3D; 0; y &lt; n; ++y) &#123;\n                if (!used[y] &amp;&amp; (x &#x3D;&#x3D; -1 || dist[y] &lt; dist[x])) &#123;\n                    x &#x3D; y;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 用该点更新所有其他点的距离\n            used[x] &#x3D; true;\n            for (int y &#x3D; 0; y &lt; n; ++y) &#123;\n                dist[y] &#x3D; min(dist[y], dist[x] + g[x][y]);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 找到距离最远的点\n        int ans &#x3D; *max_element(dist.begin(), dist.end());\n        return ans &#x3D;&#x3D; inf ? -1 : ans;\n    &#125;\n&#125;;\n</code></pre>\n\n<p>优先队列优化：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class node\n&#123;\npublic:\n\tint to;\n\tint weight;\n\tnode()\n\t&#123;&#125;\n\tnode(int t, int w)\n\t&#123;\n\t\tto &#x3D; t;\n\t\tweight &#x3D; w;\n\t&#125;\n\tbool operator&lt;(const node&amp;b) const\n\t&#123;\n\t\treturn  weight &gt; b.weight;\n\t&#125;\n&#125;;\n\nvoid dijkstra()\n&#123;\n\tdist[s] &#x3D; 0;\n\n\tnow.to &#x3D; s;\n\tnow.weight &#x3D; 0;\n\n\tcnt[0] &#x3D; 0;\n\n\tpriority_queue&lt;node&gt;q;\n\tq.push(now);\n\n\twhile (!q.empty())\n\t&#123;\n\t\tnow &#x3D; q.top();\n\t\tq.pop();\n\t\tif (used[now.to] &#x3D;&#x3D; true)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tused[now.to] &#x3D; true;\n\t\tint len &#x3D; map[now.to].size();\n\t\tfor (int i &#x3D; 0; i &lt; len; i++)\n\t\t&#123;\n\t\t\ttmp &#x3D; map[now.to][i];\n\t\t\tif (dist[tmp.to] &gt; dist[now.to] + tmp.weight)\n\t\t\t&#123;\n\t\t\t\tdist[tmp.to] &#x3D; dist[now.to] + tmp.weight;\n\t\t\t\tq.push(node(tmp.to, dist[tmp.to]));\n\t\t\t\tpath[tmp.to] &#x3D; now.to;\n\t\t\t\tcnt[tmp.to] &#x3D; cnt[now.to] + 1;\n\t\t\t&#125;\n\t\t\telse if (dist[tmp.to] &#x3D;&#x3D; dist[now.to] + tmp.weight&amp;&amp;cnt[tmp.to] &gt; cnt[now.to] + 1)\n\t\t\t&#123;\n\t\t\t\tpath[tmp.to] &#x3D; now.to;\n\t\t\t\tcnt[tmp.to] &#x3D; cnt[now.to] + 1;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n</code></pre>\n\n<p>课内：</p>\n<p>引入3个辅助数组 dist[]、path[]、S[]. </p>\n<p>✓ dist[i] ： 从 源 点 s 到 顶 点 i 的 最 短 距 离 ， 初 始 时 dist[s]&#x3D;0, dist[i]&#x3D;+∞（任意 i ≠ s）. </p>\n<p>✓ path[i]：s到i最短路径上i的前驱顶点编号，初始时path[i]&#x3D; -1 . </p>\n<p>✓ S[i]：顶点i最是否在集合S中，初始时S[i]&#x3D; 0.</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int INF&#x3D;0X3f3f3f3f, N&#x3D;1e5+10;\nvoid Dijkstra(Vertex *Head,int n,int s,int dist[],int path[])&#123;\n\tint S[N], i, j, min, v, w;\n    \n\tfor(i&#x3D;1; i&lt;&#x3D;n; i++) &#123;path[i]&#x3D;-1; dist[i]&#x3D;INF; S[i]&#x3D;0;&#125;&#x2F;&#x2F;初始化\n\tdist[s]&#x3D;0;\n    \n\tfor(i&#x3D;1; i&lt;&#x3D;n; i++) &#123;\n\t\tmin&#x3D;INF; &#x2F;&#x2F;从不在S集合中的顶点中选D值最小的顶点v\n\t\tfor(j&#x3D;1;j&lt;&#x3D;n;j++) if(S[j]&#x3D;&#x3D;0 &amp;&amp; dist[j]&lt;min)&#123;min&#x3D;dist[j];v&#x3D;j;&#125;\n        \n\t\tS[v]&#x3D;1; &#x2F;&#x2F;将顶点v放入S集合\n        \n\t\tfor(Edge* p&#x3D;Head[v].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link) &#123;\n\t\t\tw&#x3D;p-&gt;VerAdj; &#x2F;&#x2F;更新v的邻接顶点的D值\n\t\t\tif(S[w]&#x3D;&#x3D;0 &amp;&amp; dist[v]+p-&gt;cost&lt;dist[w]) &#123;\n\t\t\t\tdist[w]&#x3D;dist[v]+p-&gt;cost; \n                path[w]&#x3D;v;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid PrintPath(int path[], int s, int t)&#123;\n\t&#x2F;&#x2F;输出s到t的最短路\n\tif(s&#x3D;&#x3D;t) &#123;printf(“%d ”,s); return;&#125;\n\t\tPrintPath(s,path[t]);&#x2F;&#x2F;输出s到t前驱的最短路\n\t\tprintf(“%d ”,t); &#x2F;&#x2F;输出t\n&#125;\n</code></pre>\n\n<p>初始时（ s为源点），令Ds &#x3D;0且 Di &#x3D; ∞ （任意 i≠ s）； </p>\n<p>①从不在集合S中的顶点选择Dv最小的顶点v，将其放入集合S； </p>\n<p>②考察v的不在S中的邻接顶点w，若Dv+weight(v,w) &lt; Dw，则更新Dw， 使Dw&#x3D;Dv+weight(v,w) . </p>\n<p>③重复① ② ，直至所有顶点都放入集合S。</p>\n<p>Dijkstra算法总结不能处理负权图。选出D值最小的顶点v， 加入集合S后，源点到v的最短距离即确定。但在负权图中， v加入集合S后，源点到v的最短距离也不确定。</p>\n<h4 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman-Ford\"></a>Bellman-Ford</h4><p>第k次迭代，一定找到V1到各点的至多包含k条边的最短距离</p>\n<p>最短路径最多包含全部n个顶点，n-1条 边，即V1到各点的最短路径至多包含n-1条边，故至多迭代 n-1次。</p>\n<p>如果n-1次迭代后，再做1次迭代，最短路径还有变化，则肯 定含有负环。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool Bellman_Ford(Edge ed[], int s, int n, int e, int D[])&#123;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++) D[i]&#x3D;INF; &#x2F;&#x2F;初始化\n\tD[s]&#x3D;0;\n\tfor(int i&#x3D;1; i&lt;&#x3D;n-1; i++) &#x2F;&#x2F;n-1轮松弛操作\n    &#123;\n        &#x2F;&#x2F;不需要去寻找起点，其他点是正无穷，加上权值后仍是正无穷，不会更新\n        &#x2F;&#x2F;已经加过的边再加会大于原来的距离，不会更新\n\t\tfor(int k&#x3D;0; k&lt;e; k++) \n        &#123; &#x2F;&#x2F;扫描所有边\n\t\t\tint u&#x3D;ed[k].u; int v&#x3D;ed[k].v; int w&#x3D;ed[k].weight;\n\t\t\tif(D[u]+w&lt;D[v]) D[v]&#x3D;D[u]+w;\n\t\t&#125;\n    &#125;\n\t\n    for(int k&#x3D;0; k&lt;e; k++) \n    &#123; &#x2F;&#x2F;检测负环\n\t\tint u&#x3D;ed[k].u; int v&#x3D;ed[k].v; int w&#x3D;ed[k].weight;\n\t\tif(D[u]+w&lt;D[v]) return false; &#x2F;&#x2F;有负环\n\t&#125;\n\treturn true;\n&#125;</code></pre>\n\n<h4 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h4><p>算法采用一个队列。 初始时将源点入队，每次从队列中取 出一个顶点，并考察其邻接顶点，若某个顶点D值被更新， 则将其入队。 直至队列为空时算法结束。</p>\n<p>最坏情况下时间复杂度与Bellman-Ford算法相同，为O(ne)。 但在稀疏图上运行效率较高，为O(ke)，其中k为一个较小的 常数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool SPFA(Vertex* Head, int n, int s, int D[]) &#123;\n\tQueue Q; \n    int InQueue[N]&#x3D;&#123;0&#125;, times[N]&#x3D;&#123;0&#125;, D[N];\n\tmemset(D, 0x3f, sizeof(D));\n\tD[s] &#x3D; 0; Q.ENQUEUE(s); InQueue[s] &#x3D; 1; times[s]++;\n\twhile(!Q.Empty()) \n    &#123;\n\t\tint u &#x3D; Q.DEQUEUE(); InQueue[u] &#x3D; 0;\n\t\tfor (Edge* p &#x3D; Head[u].adjacent; p !&#x3D; NULL; p &#x3D; p-&gt;link) \n        &#123;\n\t\t\tint v &#x3D; p-&gt;VerAdj;\n\t\t\tif(D[u] + p-&gt;cost &lt; D[v]) &#123;\n\t\t\t\tD[v] &#x3D; D[u] + p-&gt;cost;\n\t\t\t\tif(!InQueue[v]) \n                &#123;\n\t\t\t\t\tQ.ENQUEUE(v); InQueue[v] &#x3D; 1; times[v]++; &#x2F;&#x2F;入队次数+1\n\t\t\t\t\tif(times[v] &gt;&#x3D; n) return false; &#x2F;&#x2F;入队次数&gt;&#x3D;n则存在负环\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn true;\n&#125;\n</code></pre>\n\n<p>✓顶点可以多次进出队 </p>\n<p>✓ 顶点每次入队D值更新1次 </p>\n<p>✓ 若入队次数大于等于n次，则存在负环</p>\n<h4 id=\"FLOYD\"><a href=\"#FLOYD\" class=\"headerlink\" title=\"FLOYD\"></a>FLOYD</h4><p>用邻接矩阵存图在A中，D中存储最短路径长度，path中存储路径当前节点的下一个节点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Floyd(int **A, int n, int **D, int **path)\n&#123; \n\tfor(int i&#x3D;1; i&lt;&#x3D;n; i++) &#x2F;&#x2F;初始化\n\t\tfor(int j&#x3D;1; j&lt;&#x3D;n; j++) \n\t\t&#123;\n\t\t\tD[i][j]&#x3D;A[i][j];\n\t\t\tif(i!&#x3D;j &amp;&amp; A[i][j]&lt;INF) path[i][j]&#x3D;j;\n\t\t\telse path[i][j]&#x3D;-1;\n\t\t&#125;\n\tfor(int k&#x3D;1; k&lt;&#x3D;n; k++) &#x2F;&#x2F;递推构造D\n\t&#123;\n\t\tfor(int i&#x3D;1; i&lt;&#x3D;n; i++)\n\t\t&#123;\n\t\t\tfor(int j&#x3D;1; j&lt;&#x3D;n; j++)\n\t\t\t&#123;\n\t\t\t\tif(D[i][k]+D[k][j]&lt;D[i][j])\n\t\t\t\t&#123;\n\t\t\t\t\tD[i][j]&#x3D;D[i][k]+D[k][j];\n\t\t\t\t\tpath[i][j]&#x3D;path[i][k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid PrintPath(int s, int t) &#123;\n\tprintf(&quot;%d &quot;, s); \n\tint k &#x3D; s;\n\twhile (k !&#x3D; t) &#123;\n\t\tprintf(&quot;%d &quot;, path[k][t]);\n\t\tk &#x3D; path[k][t];\n\t&#125;\n&#125;</code></pre>\n\n<p>Floyd算法的时间复杂度为O(n 3 )，与调用n次Dijkstra算法求 每对顶点的最短路的时间基本相当，但Floyd算法形式简单、 算法紧凑、便于实现，允许负权边。</p>\n<p>适用于有向图，也适用于无向图。</p>\n<p>不允许存在负环（环上所有边的权值和为负数，理论上不存 在最短路）。Floyd算法可以判负环，初始时D[i][i]&#x3D;0，算法 执行过程中若D[i][i]&lt;0，表示顶点i到自己的最短距离为负值， 即存在负环。（注意是D[i][i]!)</p>\n<h4 id=\"传递闭包问题Warshall算法\"><a href=\"#传递闭包问题Warshall算法\" class=\"headerlink\" title=\"传递闭包问题Warshall算法\"></a>传递闭包问题Warshall算法</h4><p>不关注路径长度，而是仅关注是否存在路径。 </p>\n<p>vi和vj是有向图G的两个顶点 , 若从 vi到 vj存在一条路径，则称 vi 到 vj可及；</p>\n<p> 传递性: 若 vi到 vj ，vj到 vk皆可及，则 vi 到vk可及. </p>\n<p>描述有向图顶点间可及关系的n阶方阵R称为可及矩阵，若顶 点vi到vj可及，则Rij &#x3D;1，否则Rij &#x3D;0. </p>\n<p>传递闭包: 由有向图 G 的顶点集 V、边集 E，以及新添加的虚 边（表示两顶点可及）构成的图被称为 G 的传递闭包。</p>\n<p>R(k-1) [i][j]表示顶点 i经由{v1 , … ,vk-1 }中顶点到达 j 的可及性. </p>\n<p>R(k) [i][j]表示顶点 i经由{v1 ,… ,vk-1 ,vk }中顶点到达j的可及性. </p>\n<p>R(k) [i][ j] &#x3D; R( k−1)[i][j] OR (R(k−1) [i][k] AND R(k−1)[k][j])</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;简单优化后\nvoid Warshall(int A[N][N], int n, int R[N][N]) &#123; \n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) \n\t\t\tif (i&#x3D;&#x3D;j || A[i][j]&lt;INF) R[i][j] &#x3D; 1; \n\t\t\t&#x2F;&#x2F;i和j之间存在边，注意对对无权图是A[i][j]&#x3D;&#x3D;1\n\t\t\telse R[i][j] &#x3D; 0;\n\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#x2F;&#x2F;递推构造Rn\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif(R[i][k])\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif(R[k][j])\n\t\t\t\t\tR[i][j] &#x3D; 1;\n&#125; </code></pre>\n\n<h4 id=\"变式\"><a href=\"#变式\" class=\"headerlink\" title=\"变式\"></a>变式</h4><p>对于负权图最短路径问题，若图中最小边权是-x（x&gt;0），做一个变换，将所有边的权值加上 x+1，使所有边权值变为正数，再调用Dijkstra求最短路径，该最短 路就是原图的最短路。</p>\n<p>求图的最长路径 :</p>\n<p>对Dijkstra算法稍加修改，将算法中D[v]+weight(v,w)&lt;D[w] 改为D[v]+weight(v,w)&gt;D[w] 。</p>\n<p>若权值都为正，则对所权值取倒数，用Dijkstra算法求最短路径，该 路径就是原图的最长路径。</p>\n<p>若图中不存在正环，对所有边的权值取相反数，执行Floyd或 Bellman-Ford算法求最短路径，该路径就是原图的最长路。</p>\n<h4 id=\"满足约束的最短路径\"><a href=\"#满足约束的最短路径\" class=\"headerlink\" title=\"满足约束的最短路径\"></a>满足约束的最短路径</h4><h5 id=\"K-站中转内最短路径\"><a href=\"#K-站中转内最短路径\" class=\"headerlink\" title=\"K 站中转内最短路径\"></a>K 站中转内最短路径</h5><p>使用课内方法是没有次序的随意更新，二维数组可以记录来自不同路径的最短路，避免前一半路径与后一半路径使用的是不同路径</p>\n<p>基于Bellman—Ford：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;图论中带边数限制的最短路 Bellman—Ford算法\n    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;\n        vector&lt;vector&lt;int&gt;&gt; dp(k+2,vector&lt;int&gt;(n,INT_MAX&#x2F;2));&#x2F;&#x2F;dp[t][j]表示遍历t条边到达目的地j的最短路径\n        dp[0][src]&#x3D;0;\n        int res&#x3D;INT_MAX&#x2F;2;\n        for(int t&#x3D;1;t&lt;&#x3D;k+1;t++)&#123;\n            for(auto&amp; flight:flights)&#123;\n                int i&#x3D;flight[0];\n                int j&#x3D;flight[1];\n                int dis&#x3D;flight[2];\n                dp[t][j]&#x3D;min(dp[t][j],dp[t-1][i]+dis);\n                if(j&#x3D;&#x3D;dst)res&#x3D;min(res,dp[t][j]);\n            &#125;\n        &#125;\n        return res&#x3D;&#x3D;INT_MAX&#x2F;2?-1:res;\n    &#125;\n&#125;;\n</code></pre>\n\n<p>基于狄克斯特拉：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Edge&#123;\n    int id;\n    int trans;\n    int efforts;\n    Edge(int _id,int _trans,int _efforts):id(_id),trans(_trans),efforts(_efforts)&#123;&#125;\n    bool operator&lt;(const Edge&amp; edge)const&#123;\n        return efforts&gt;edge.efforts;\n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;有向图求最短路\n    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;\n        vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; graph(n);\n        for(int i&#x3D;0;i&lt;flights.size();i++)&#123;\n            int cur&#x3D;flights[i][0];\n            int next&#x3D;flights[i][1];\n            int dis&#x3D;flights[i][2];\n            graph[cur].push_back(&#123;next,dis&#125;);\n        &#125;\n        vector&lt;int&gt; dis(n,INT_MAX);\n        vector&lt;int&gt; transtimes(n,INT_MAX);\n        priority_queue&lt;Edge&gt; pq;\n        pq.push(&#123;src,0,0&#125;);\n        dis[src]&#x3D;0;\n        transtimes[src]&#x3D;0;\n        while(!pq.empty())&#123;\n           Edge edge&#x3D;pq.top();\n           pq.pop();\n           if(edge.trans&gt;k)continue;\n           if(edge.id&#x3D;&#x3D;dst)return edge.efforts;\n           for(auto&amp; flight:graph[edge.id])&#123;\n               int nextid&#x3D;flight.first;\n               int nextefforts&#x3D;edge.efforts+flight.second;\n               int nexttrans&#x3D;edge.trans;\n               if(nextid!&#x3D;dst)nexttrans+&#x3D;1;\n               if(dis[nextid]&gt;nextefforts)&#123;\n                   dis[nextid]&#x3D;nextefforts;\n                   transtimes[nextid]&#x3D;nexttrans;\n               &#125;\n               if(dis[nextid]&lt;nextefforts &amp;&amp; nexttrans&gt;transtimes[nextid])continue;\n               pq.push(&#123;nextid,nexttrans,nextefforts&#125;); \n           &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n</code></pre>\n\n<h3 id=\"最小支撑树\"><a href=\"#最小支撑树\" class=\"headerlink\" title=\"最小支撑树\"></a>最小支撑树</h3><p>无向带权连通图G，其顶点个数为n，由G中n个顶点和n-1条边 构成的连通子图，称为G的一棵支撑树，亦称生成树。边权之 和最小的支撑树称为G的最小支撑树。(Minimum Spanning Tree, MST )。</p>\n<p>性质：无回路</p>\n<h4 id=\"kruskal\"><a href=\"#kruskal\" class=\"headerlink\" title=\"kruskal\"></a>kruskal</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n<h4 id=\"prim\"><a href=\"#prim\" class=\"headerlink\" title=\"prim\"></a>prim</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ol>\n<li>定义 : 堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 故通常我们用完全二叉树来维护一个一维数组</li>\n<li>分类 : 按照堆的特点可以把堆分为大顶堆和小顶堆<br>———-大顶堆：每个结点的值都大于或等于其左右孩子结点的值<br>———-小顶堆：每个结点的值都小于或等于其左右孩子结点的值</li>\n</ol>\n<p>  3.完全二叉树维护的一维数组的特点</p>\n<p>对于完全二叉树来说，⌊<em>N</em>&#x2F;2⌋得到的是最后一个非叶子节点的序号</p>\n<p>在完全二叉树中我们发现关系就是 如果父节点的序号为 x, 那么其左孩子节点若存在其序号为 2 * x, 右孩子存在则其序号为 2 * x + 1; 那么一个节点的父节点则为 x &#x2F; 2; 故根据这个序号特点，我们将序号作为数组的下标，将一颗完全二叉树用一个一维数组存储。</p>\n<p>建立大根堆</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvoid heapadjust(vector&lt;int&gt;&amp;store, int k,int len)\n&#123;\n\tstore[0] &#x3D; store[len];\n\tfor (int i &#x3D; 2 * k; i &lt;&#x3D; len; i*&#x3D;2)\n\t&#123;\n\t\tif (i &lt; len&amp;&amp;store[i] &lt; store[i + 1])\n\t\t\ti++;\n\t\tif (store[0] &gt; store[i])\n\t\t\tbreak;\n\t\telse\n\t\t&#123;\n\t\t\tstore[k] &#x3D; store[i];\n\t\t\tk &#x3D; i;\n\t\t&#125;\n\t&#125;\n\tstore[k] &#x3D; store[0];\n&#125;\n\nvoid buildMaxHeap(vector&lt;int&gt;&amp;store,int len)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len &#x2F; 2; i &gt; 0; i--)\n\t&#123;\n\t\theapadjust(store, i);\n\t&#125;\n&#125;</code></pre>\n\n<p>堆排序</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void heapSort(vector&lt;int&gt;&amp;store)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len; i &gt;1; i--)\n\t&#123;\n\t\tswap(store[i], store[1]);\n\t\theapadjust(store, 1,i-1);\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>priority_queue<br>优先队列是一种会按照默认或自定义的优先级进行自动排序的队列，其特点是优先级高的元素排在队首，低的排在队尾。</p>\n<p><strong>创建</strong><br>    数据类型：可以是int、double等基本类型，也可以是自定义的结构体。<br>    容器类型：一般为deque（双端列表）、vector（向量容器），可省略，省略时以vector为默认容器。</p>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h2 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><h4 id=\"标准模板\"><a href=\"#标准模板\" class=\"headerlink\" title=\"标准模板\"></a>标准模板</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int binarysearch(vector&lt;int&gt;nums, int target)\n&#123;\n\tint left &#x3D; 0;\n\tint right &#x3D; nums.size()-1;\n\n\twhile (left &lt;&#x3D; right)\n\t&#123;\n\t\tint mid &#x3D; left + (right - left) &#x2F; 2;\n\t\tif (nums[mid] &#x3D;&#x3D; target)\n\t\t&#123;\n\t\t\treturn mid;\n\t\t&#125;\n\t\telse if (nums[mid] &lt; target)\n\t\t&#123;\n\t\t\tleft &#x3D; mid + 1;\n\t\t&#125;\n\t\telse if (nums[mid] &gt; target)\n\t\t&#123;\n\t\t\tright &#x3D; mid - 1;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n\n&#125;\n              </code></pre>\n\n<h5 id=\"为什么-while-循环的条件中是-lt-x3D-，而不是-lt-？\"><a href=\"#为什么-while-循环的条件中是-lt-x3D-，而不是-lt-？\" class=\"headerlink\" title=\"为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt; ？\"></a>为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt; ？</h5><p>因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。</p>\n<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。</p>\n<p>我们这个算法中使用的是 [left, right] 两端都闭的区间。<strong>这个区间就是每次进行搜索的区间，我们不妨称为「搜索区间」</strong></p>\n<p>while(left &lt;&#x3D; right)的终止条件是 left &#x3D;&#x3D; right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见<strong>这时候搜索区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>\n<p>while(left &lt; right)的终止条件是 left &#x3D;&#x3D; right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，<strong>这时候搜索区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就可能出现错误。</p>\n<h5 id=\"2-为什么-left-x3D-mid-1，right-x3D-mid-1？我看有的代码是-right-x3D-mid-或者-left-x3D-mid，没有这些加加减减，到底怎么回事，怎么判断？\"><a href=\"#2-为什么-left-x3D-mid-1，right-x3D-mid-1？我看有的代码是-right-x3D-mid-或者-left-x3D-mid，没有这些加加减减，到底怎么回事，怎么判断？\" class=\"headerlink\" title=\"2. 为什么 left &#x3D; mid + 1，right &#x3D; mid - 1？我看有的代码是 right &#x3D; mid 或者 left &#x3D; mid，没有这些加加减减，到底怎么回事，怎么判断？\"></a><em>2</em>. 为什么 left &#x3D; mid + 1，right &#x3D; mid - 1？我看有的代码是 right &#x3D; mid 或者 left &#x3D; mid，没有这些加加减减，到底怎么回事，怎么判断？</h5><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？</p>\n<p>当然是去搜索 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。</p>\n<h4 id=\"红蓝通用模板\"><a href=\"#红蓝通用模板\" class=\"headerlink\" title=\"红蓝通用模板\"></a>红蓝通用模板</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int find(vector&lt;int&gt;&amp;nums,int bound,int target)\n    &#123;\n        int len&#x3D;nums.size();\n        int left&#x3D;-1;\n        int right&#x3D;bound;\n        while(left+1!&#x3D;right)\n        &#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            if(nums[mid]&lt;target)\n            &#123;\n                left&#x3D;mid;\n            &#125;\n            else\n            &#123;\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        return left;\n    &#125;\nCEFDBHGA\nCBEDFAGH</code></pre>\n\n<h3 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h3><h4 id=\"性质-1\"><a href=\"#性质-1\" class=\"headerlink\" title=\"性质\"></a>性质</h4><p>在二叉搜索树中：</p>\n<p> 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</p>\n<p> 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</p>\n<p> 任意节点的左、右子树也分别为二叉查找树。</p>\n<p> 没有键值相等的节点（no duplicate nodes）。</p>\n<p>对一颗二叉树进行中序遍历，可以按从小到大的顺序，将各结点关键码排列起来，所以也称二叉搜索树为二叉排序树</p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>插入：</p>\n<p>在寻找插入位置的过程中确定元素是否已经存在</p>\n<p>删除：</p>\n<p>分四种情况：</p>\n<p>如果想要删除叶结点，只需将其父结点指向它的指针清零，再释放它即可。</p>\n<p>如果被删结点右子树为空，可以拿它的左子女结点顶替它的位置，再释放它。</p>\n<p>如果被删结点左子树为空，可以拿它的右子女结点顶替它的位置，再释放它。</p>\n<p>如果被删结点左、右子树都不空。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e6882e5134e9b7966228d2f809deb5ee.png\" alt=\"二叉搜索树的详细实现-图2\"></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;二叉搜索树结点类型\ntemplate&lt;typename T&gt;\nstruct BSTNode\n&#123;\n\tT data;    &#x2F;&#x2F;数据域\n\tBSTNode&lt;T&gt; *left, *right;    &#x2F;&#x2F;左子女、右子女\n\tBSTNode() :left(NULL), right(NULL) &#123;&#125;    &#x2F;&#x2F;构造函数\n\t&#x2F;&#x2F;构造函数\n\tBSTNode(const T d, BSTNode&lt;T&gt;* L &#x3D; NULL, BSTNode&lt;T&gt;* R &#x3D; NULL) :data(d), left(L), right(R) &#123;&#125;\n&#125;;\n\n&#x2F;&#x2F;二叉搜索树的定义\ntemplate &lt;class T&gt;\nclass BST\n&#123;\npublic:\n\t&#x2F;&#x2F;普通构造函数\n\tBST() :root(NULL) &#123;&#125;\n\t&#x2F;&#x2F;构造BST\n\tBST(T value) :root(NULL), RefValue(value)\n\t&#123;\n\t\tT x;\n\t\tcin &gt;&gt; x;\n\t\twhile (x !&#x3D; RefValue)\n\t\t&#123;\n\t\t\tInsert(x, root);    &#x2F;&#x2F;新建一个结点，调用Insert插入到树中\n\t\t\tcin &gt;&gt; x;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;析构\n\t~BST() &#123; Destroy(root); &#125;\n\t&#x2F;&#x2F;插入\n\tbool Insert(T x) &#123; return Insert(x, root); &#125;\n\t&#x2F;&#x2F;删除\n\tbool Remove(T x) &#123; return Remove(x, root); &#125;\n\t&#x2F;&#x2F;搜索\n\tbool Search(T x) &#123; return (Search(x, root) !&#x3D; NULL) ? true : false; &#125;\n\t&#x2F;&#x2F;中序遍历\n\tvoid InOrder() &#123; InOrder(root); &#125;\n\nprotected:\n\n\t&#x2F;&#x2F;以ptr为根的二叉搜索树中插入所含值为e1的结点\n\tbool Insert(const T&amp; e1, BSTNode&lt;T&gt;* &amp;ptr)    &#x2F;&#x2F;第二个参数是指针的引用\n\t&#123;\n\t\tif (ptr &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\tptr &#x3D; new BSTNode&lt;T&gt;(e1);    &#x2F;&#x2F;构造新结点\n\t\t\tif (ptr &#x3D;&#x3D; NULL)\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; endl;\n\t\t\t\texit(1);\n\t\t\t&#125;\n\t\t\treturn true;\n\t\t&#125;\n\t\telse if (e1 &lt; ptr-&gt;data)    &#x2F;&#x2F;小于，插入左子树\n\t\t&#123;\n\t\t\tInsert(e1, ptr-&gt;left);\n\t\t&#125;\n\t\telse if (e1 &gt; ptr-&gt;data)    &#x2F;&#x2F;大于，插入右子树\n\t\t&#123;\n\t\t\tInsert(e1, ptr-&gt;right);\n\t\t&#125;\n\t\telse    &#x2F;&#x2F;x已在树中，不插入\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;以ptr为根的二叉搜索树中删除含x的结点\n\tbool Remove(T x, BSTNode&lt;T&gt;* &amp;ptr)\n\t&#123;\n\t\tBSTNode&lt;T&gt;* temp;\n\t\tif (ptr !&#x3D; NULL) &#x2F;&#x2F;ptr不为空进行操作\n\t\t&#123;\n\t\t\tif (x &lt; ptr-&gt;data)\n\t\t\t&#123;\n\t\t\t\tRemove(x, ptr-&gt;left);\n\t\t\t&#125;\n\t\t\telse if (x &gt; ptr-&gt;data)\n\t\t\t&#123;\n\t\t\t\tRemove(x, ptr-&gt;right);\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F;找到了要删除的结点\n\t\t\t&#x2F;&#x2F;1.要删除的结点ptr同时有左右子树\n\t\t\telse if (ptr-&gt;left !&#x3D; NULL &amp;&amp; ptr-&gt;right !&#x3D; NULL)\n\t\t\t&#123;\n\t\t\t\ttemp &#x3D; ptr-&gt;right;    &#x2F;&#x2F;在右子树中搜索中序下的第一个结点\n\t\t\t\twhile (temp-&gt;left !&#x3D; NULL)\n\t\t\t\t&#123;\n\t\t\t\t\ttemp &#x3D; temp-&gt;left;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;用右子树中序下的第一个结点的值填充要删除的结点\n\t\t\t\tptr-&gt;data &#x3D; temp-&gt;data;\n\t\t\t\t&#x2F;&#x2F;然后再新填充值ptr的右子树中删除temp的data值\n\t\t\t\tRemove(ptr-&gt;data, ptr-&gt;right);\n\t\t\t&#125;\n\t\t\telse &#x2F;&#x2F;不同时有左右子树\n\t\t\t&#123;\n\t\t\t\ttemp &#x3D; ptr;        &#x2F;&#x2F;temp记住要删除的ptr结点\n\t\t\t\tif (ptr-&gt;left &#x3D;&#x3D; NULL) &#x2F;&#x2F;只有右子树\n\t\t\t\t&#123;\n\t\t\t\t\tptr &#x3D; ptr-&gt;right;\n\t\t\t\t&#125;\n\t\t\t\telse    &#x2F;&#x2F;只有左子树\n\t\t\t\t&#123;\n\t\t\t\t\tptr &#x3D; ptr-&gt;left;\n\t\t\t\t&#125;\n\t\t\t\tdelete temp;    &#x2F;&#x2F;删除结点\n\t\t\t\ttemp &#x3D; NULL;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse &#x2F;&#x2F;ptr为空直接返回false\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;在ptr为根的二叉搜索树中搜索含x的结点。若找到，返回该结点地址，否则返回NULL\n\tBSTNode&lt;T&gt;* Search(T x, BSTNode&lt;T&gt;* ptr)\n\t&#123;\n\t\tif (ptr &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\treturn NULL;\n\t\t&#125;\n\t\telse if (x &lt; ptr-&gt;data)\n\t\t&#123;\n\t\t\treturn Search(x, ptr-&gt;left);\n\t\t&#125;\n\t\telse if (x &gt; ptr-&gt;data)\n\t\t&#123;\n\t\t\treturn Search(x, ptr-&gt;right);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn ptr;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;中序遍历\n\tvoid InOrder(BSTNode&lt;T&gt;* root)\n\t&#123;\n\t\tif (root !&#x3D; NULL)\n\t\t&#123;\n\t\t\tInOrder(root-&gt;left);\n\t\t\tcout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;\n\t\t\tInOrder(root-&gt;right);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;销毁以root为根的二叉树搜索树函数\n\tvoid Destroy(BSTNode&lt;T&gt;* &amp;root)\n\t&#123;\n\t\tif (root &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (root-&gt;left !&#x3D; NULL)\n\t\t&#123;\n\t\t\tDestroy(root-&gt;left);\n\t\t&#125;\n\t\tif (root-&gt;right !&#x3D; NULL)\n\t\t&#123;\n\t\t\tDestroy(root-&gt;right);\n\t\t&#125;\n\t\tdelete root;\n\t\troot &#x3D; NULL;\n\t&#125;\nprivate:\n\tBSTNode&lt;T&gt;* root;    &#x2F;&#x2F;根指针\n\tT RefValue;    &#x2F;&#x2F;输入结束标识\n&#125;;</code></pre>\n\n\n\n<h3 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li><p>它的左右子树都是AVL树</p>\n</li>\n<li><p>左右子树高度之差(简称平衡因子)的绝对值不超过1(-1&#x2F;0&#x2F;1)</p>\n</li>\n<li><p>平衡因子的计算是右子树的高度减去左子树的高度的差值结果</p>\n</li>\n<li><p>四种旋转</p>\n<p>b站视频很清晰</p>\n</li>\n</ol>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nclass AVLnode &#123;\npublic:\n\tAVLnode(const T&amp; el) &#123;\n\t\tinfo &#x3D; el;\n\t\tleft &#x3D; nullptr;\n\t\tright &#x3D; nullptr;\n\t\theight &#x3D; 1;\n\t&#125;\n\tAVLnode&lt;T&gt; *left, *right;\n\tT info;      &#x2F;&#x2F;节点储存值\n\tint height;\n&#125;;\n\ntemplate&lt;class T&gt;\nclass AVLTree &#123;\npublic:\n\tAVLTree() &#123;\n\t\troot &#x3D; nullptr;\n\t&#125;\n\t&#x2F;&#x2F;定义左旋操作\n\tAVLnode&lt;T&gt;* L_rotate(AVLnode&lt;T&gt; *p);\n\t&#x2F;&#x2F;定义右旋操作\n\tAVLnode&lt;T&gt;* R_rotate(AVLnode&lt;T&gt; *p);\n\t&#x2F;&#x2F;左子树右旋，再左旋\n\tAVLnode&lt;T&gt;* LR_rotate(AVLnode&lt;T&gt; *p);\n\t&#x2F;&#x2F;右子树左旋，再右旋\n\tAVLnode&lt;T&gt;* RL_rotate(AVLnode&lt;T&gt; *p);\n\n\tvoid insert(const T&amp; el);\n\tAVLnode&lt;T&gt;* insert_(AVLnode&lt;T&gt;* &amp;p, const T&amp; el);\n\n\tAVLnode&lt;T&gt;* search(const T&amp; el) const;\n\tvoid remove(const T&amp; el);\n\tAVLnode&lt;T&gt;* remove_(AVLnode&lt;T&gt;* &amp;p, AVLnode&lt;T&gt;* cur);\n\tAVLnode&lt;T&gt;* maxleft(AVLnode&lt;T&gt;* p);\n\tAVLnode&lt;T&gt;* minright(AVLnode&lt;T&gt;* p);\n\t&#x2F;&#x2F;获取某个节点的高度\n\tint GetHeight(AVLnode&lt;T&gt; *p) const &#123;\n\t\tif (p &#x3D;&#x3D; nullptr) return 0;\n\t\treturn p-&gt;height;\n\t&#125;\n\n\tAVLnode&lt;T&gt;* root;\n\n&#125;;\n\n&#x2F;&#x2F;以p节点为根左旋\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::L_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;left;\n\tp-&gt;left &#x3D; l-&gt;right;\n\tl-&gt;right &#x3D; p;\n\t&#x2F;&#x2F;更新高度\n\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\tl-&gt;height &#x3D; max(GetHeight(l-&gt;left), GetHeight(l-&gt;right)) + 1;\n\t&#x2F;&#x2F;返回新的根节点l\n\treturn l;\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::R_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;right;\n\tp-&gt;right &#x3D; l-&gt;left;\n\tl-&gt;left &#x3D; p;\n\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\tl-&gt;height &#x3D; max(GetHeight(l-&gt;left), GetHeight(l-&gt;right)) + 1;\n\treturn l;\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::LR_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;left;\n\tp-&gt;left &#x3D; R_rotate(l);\n\treturn L_rotate(p);\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::RL_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;right;\n\tp-&gt;right &#x3D; L_rotate(l);\n\treturn R_rotate(p);\n&#125;\n\ntemplate&lt;class T&gt;\nvoid AVLTree&lt;T&gt;::insert(const T&amp; el) &#123;\n\tinsert_(root, el);\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::insert_(AVLnode&lt;T&gt;* &amp;p, const T&amp; el) &#123;\n\tif (p &#x3D;&#x3D; nullptr) &#123;\n\t\tp &#x3D; new AVLnode&lt;T&gt;(el);\n\t\tif (p &#x3D;&#x3D; nullptr)\n\t\t\tcout &lt;&lt; &quot;failed to insert a new node&quot; &lt;&lt; endl;\n\t&#125;\n\telse if (el &lt; p-&gt;info) &#123;\n\t\tp-&gt;left &#x3D; insert_(p-&gt;left, el);\n\t\t&#x2F;&#x2F;回溯判断新树是否失衡\n\t\tif (GetHeight(p-&gt;left) - GetHeight(p-&gt;right) &gt; 1) &#123;\n\t\t\tif (el &lt; p-&gt;left-&gt;info) p &#x3D; L_rotate(p);\n\t\t\telse p &#x3D; LR_rotate(p);\n\t\t&#125;\n\t&#125;\n\telse if (el &gt; p-&gt;info) &#123;\n\t\tp-&gt;right &#x3D; insert_(p-&gt;right, el);\n\t\tif (GetHeight(p-&gt;right) - GetHeight(p-&gt;left) &gt; 1) &#123;\n\t\t\tif (el &gt; p-&gt;right-&gt;info) p &#x3D; R_rotate(p);\n\t\t\telse p &#x3D; RL_rotate(p);\n\t\t&#125;\n\t&#125;\n\telse cout &lt;&lt; &quot;this node is in the tree already!&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;更新节点高度\n\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\treturn p;\n&#125;\n\ntemplate&lt;class T&gt;\nvoid AVLTree&lt;T&gt;::remove(const T&amp; el) &#123;\n\t&#x2F;&#x2F;search接口与普通二叉树定义一样，返回指向该节点的指针\n\tAVLnode&lt;T&gt;* cur &#x3D; search(el);\n\tif (cur !&#x3D; nullptr)\n\t\troot &#x3D; remove_(root, cur);\n&#125;\n\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::remove_(AVLnode&lt;T&gt;* &amp;p, AVLnode&lt;T&gt;* cur) &#123;\n\tif (cur-&gt;info &lt; p-&gt;info) &#123;\n\t\tp-&gt;left &#x3D; remove_(p-&gt;left, cur);\n\t\tif (GetHeight(p-&gt;right) - GetHeight(p-&gt;left) &gt; 1) &#123;\n\t\t\tif (GetHeight(p-&gt;right-&gt;right) &gt; GetHeight(p-&gt;right-&gt;left))\n\t\t\t\tp &#x3D; R_rotate(p);\n\t\t\telse p &#x3D; RL_rotate(p);\n\t\t&#125;\n\t&#125;\n\telse if (cur-&gt;info &gt; p-&gt;info) &#123;\n\t\tp-&gt;right &#x3D; remove_(p-&gt;right, cur);\n\t\tif (GetHeight(p-&gt;left) - GetHeight(p-&gt;right) &gt; 1) &#123;\n\t\t\tif (GetHeight(p-&gt;left-&gt;left) &gt; GetHeight(p-&gt;left-&gt;right))\n\t\t\t\tp &#x3D; L_rotate(p);\n\t\t\telse p &#x3D; LR_rotate(p);\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;找到被删除节点的位置\n\telse &#123;\n\n\t\tif (p-&gt;left !&#x3D; nullptr &amp;&amp; p-&gt;right !&#x3D; nullptr) &#123;\n\t\t\tif (GetHeight(p-&gt;left) &gt; GetHeight(p-&gt;right)) &#123;\n\t\t\t\t&#x2F;&#x2F;maxleft返回指向左子树的最大值节点，这里类似于复制删除\n\t\t\t\tAVLnode&lt;T&gt;* tem &#x3D; maxleft(p-&gt;left);\n\t\t\t\tp-&gt;info &#x3D; tem-&gt;info;\n\t\t\t\t&#x2F;&#x2F;转换成删除另外一个节点\n\t\t\t\tremove_(p-&gt;left, tem);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\t&#x2F;&#x2F;minright返回右子树的最小值节点\n\t\t\t\tAVLnode&lt;T&gt;* tem &#x3D; minright(p-&gt;right);\n\t\t\t\tp-&gt;info &#x3D; tem-&gt;info;\n\t\t\t\tremove_(p-&gt;right, tem);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F;实际的删除操作发生在这里\n\t\t\tAVLnode&lt;T&gt;* tem &#x3D; p;\n\t\t\tp &#x3D; (p-&gt;left &#x3D;&#x3D; nullptr) ? p-&gt;right : p-&gt;left;\n\t\t\tdelete tem;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;更新高度，注意这里若p是空就不需要更新了，\n\t&#x2F;&#x2F;直接回溯到上一层递归更新高度即可\n\tif (p !&#x3D; nullptr)\n\t\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\treturn p;\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;*  AVLTree&lt;T&gt;::maxleft(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt;* cur &#x3D; p, *pre &#x3D; p;\n\twhile (cur !&#x3D; nullptr) &#123;\n\t\tpre &#x3D; cur;\n\t\tcur &#x3D; cur-&gt;right;\n\t&#125;\n\treturn pre;\n&#125;\n\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;*  AVLTree&lt;T&gt;::minright(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt;* cur &#x3D; p, *pre &#x3D; p;\n\twhile (cur !&#x3D; nullptr) &#123;\n\t\tpre &#x3D; cur;\n\t\tcur &#x3D; cur-&gt;left;\n\t&#125;\n\treturn pre;\n&#125;\n</code></pre>\n\n\n\n<h3 id=\"b树\"><a href=\"#b树\" class=\"headerlink\" title=\"b树\"></a>b树</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： </p>\n<ul>\n<li>每个节点最多只有m个子节点。</li>\n<li>每个非叶子节点（除了根）具有至少⌈ m&#x2F;2⌉子节点。</li>\n<li>如果根不是叶节点，则根至少有两个子节点。</li>\n<li>具有<em>k</em>个子节点的非叶节点包含<em>k</em> -1个键。</li>\n<li>所有叶子都出现在同一水平，没有任何信息（高度一致）。</li>\n</ul>\n<h5 id=\"性质-2\"><a href=\"#性质-2\" class=\"headerlink\" title=\"性质\"></a>性质</h5><p>根节点：</p>\n<p>2&lt;&#x3D; M &lt;&#x3D;m，M为子节点数量</p>\n<p>1&lt;&#x3D; K &lt;&#x3D;m-1,K为元素数量</p>\n<p>（m&#x2F;2）&lt;&#x3D; M &lt;&#x3D;m</p>\n<p>m&#x2F;2）-1&lt;&#x3D; K &lt;&#x3D;m-1</p>\n<p>m&#x2F;2为认为规定，防止树的高度过高</p>\n<h4 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h4><h5 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h5><p>在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。</p>\n<ul>\n<li>若该节点元素个数小于m-1，直接插入；</li>\n<li>若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；</li>\n<li>重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1；</li>\n</ul>\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；</p>\n<p>删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；</p>\n<ul>\n<li>某结点中元素数目小于（m&#x2F;2）-1,(m&#x2F;2)向上取整，则需要看其某相邻兄弟结点是否丰满；</li>\n<li>如果丰满（结点中元素个数大于(m&#x2F;2)-1），则向父节点借一个元素来满足条件；</li>\n<li>如果其相邻兄弟都不丰满，即其结点数目等于(m&#x2F;2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；</li>\n</ul>\n<h4 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n#include&lt;iostream&gt;\nusing namespace std;\ntemplate&lt;class T&gt;\nclass CBTree\n&#123;\nprivate:\n\t&#x2F;&#x2F;m阶至多m个孩子，t度至多2t-1个关键字，即2t个孩子，t度 的B树就是 2t阶 的B树\n\tstatic const int M &#x3D; 4;                  &#x2F;&#x2F;B树的最小度数\n\tstatic const int KEY_MAX &#x3D; 2 * M - 1;        &#x2F;&#x2F;节点包含关键字的最大个数\n\tstatic const int KEY_MIN &#x3D; M - 1;          &#x2F;&#x2F;非根节点包含关键字的最小个数\n\tstatic const int CHILD_MAX &#x3D; KEY_MAX + 1;  &#x2F;&#x2F;孩子节点的最大个数\n\tstatic const int CHILD_MIN &#x3D; KEY_MIN + 1;  &#x2F;&#x2F;孩子节点的最小个数\n\tstruct Node\n\t&#123;\n\t\tbool isLeaf;             &#x2F;&#x2F;是否是叶子节点\n\t\tint keyNum;              &#x2F;&#x2F;节点包含的关键字数量\n\t\tT keyValue[KEY_MAX];     &#x2F;&#x2F;关键字的值数组\n\t\tNode *pChild[CHILD_MAX]; &#x2F;&#x2F;子树指针数组\n\n\t\tNode(bool b &#x3D; true, int n &#x3D; 0)\n\t\t\t:isLeaf(b), keyNum(n) &#123;&#125;\n\t&#125;;\npublic:\n\tCBTree()\n\t&#123;\n\t\tm_pRoot &#x3D; NULL;  &#x2F;&#x2F;创建一棵空的B树\n\t&#125;\n\n\t~CBTree()\n\t&#123;\n\t\tclear();\n\t&#125;\n\n\tbool insert(const T &amp;key)    &#x2F;&#x2F;向B数中插入新结点key\n\t&#123;\n\t\tif (contain(key))  &#x2F;&#x2F;检查该关键字是否已经存在\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tif (m_pRoot &#x3D;&#x3D; NULL)&#x2F;&#x2F;检查是否为空树\n\t\t\t&#123;\n\t\t\t\tm_pRoot &#x3D; new Node();\n\t\t\t&#125;\n\t\t\tif (m_pRoot-&gt;keyNum &#x3D;&#x3D; KEY_MAX) &#x2F;&#x2F;检查根节点是否已满\n\t\t\t&#123;\n\t\t\t\tNode *pNode &#x3D; new Node();  &#x2F;&#x2F;创建新的根节点\n\t\t\t\tpNode-&gt;isLeaf &#x3D; false;\n\t\t\t\tpNode-&gt;pChild[0] &#x3D; m_pRoot;\n\t\t\t\tsplitChild(pNode, 0, m_pRoot);\n\t\t\t\tm_pRoot &#x3D; pNode;  &#x2F;&#x2F;更新根节点指针\n\t\t\t&#125;\n\t\t\tinsertNonFull(m_pRoot, key);\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\tbool remove(const T &amp;key)    &#x2F;&#x2F;从B中删除结点key\n\t&#123;\n\t\tif (!search(m_pRoot, key))  &#x2F;&#x2F;不存在\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\tif (m_pRoot-&gt;keyNum &#x3D;&#x3D; 1)&#x2F;&#x2F;特殊情况处理\n\t\t&#123;\n\t\t\tif (m_pRoot-&gt;isLeaf)\n\t\t\t&#123;\n\t\t\t\tclear();\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tNode *pChild1 &#x3D; m_pRoot-&gt;pChild[0];\n\t\t\t\tNode *pChild2 &#x3D; m_pRoot-&gt;pChild[1];\n\t\t\t\tif (pChild1-&gt;keyNum &#x3D;&#x3D; KEY_MIN &amp;&amp; pChild2-&gt;keyNum &#x3D;&#x3D; KEY_MIN)\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(m_pRoot, 0);\n\t\t\t\t\tdeleteNode(m_pRoot);\n\t\t\t\t\tm_pRoot &#x3D; pChild1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\trecursive_remove(m_pRoot, key);\n\t\treturn true;\n\t&#125;\n\tvoid display()const &#x2F;&#x2F;打印树的关键字\n\t&#123;\n\t\tdisplayInConcavo(m_pRoot, KEY_MAX * 10);\n\t&#125;\n\tbool contain(const T &amp;key)const   &#x2F;&#x2F;检查该key是否存在于B树中\n\t&#123;\n\t\treturn search(m_pRoot, key);\n\t&#125;\n\tvoid clear()                      &#x2F;&#x2F;清空B树\n\t&#123;\n\t\trecursive_clear(m_pRoot);\n\t\tm_pRoot &#x3D; NULL;\n\t&#125;\nprivate:\n\t&#x2F;&#x2F;删除树\n\tvoid recursive_clear(Node *pNode)\n\t&#123;\n\t\tif (pNode !&#x3D; NULL)\n\t\t&#123;\n\t\t\tif (!pNode-&gt;isLeaf)\n\t\t\t&#123;\n\t\t\t\tfor (int i &#x3D; 0; i &lt;&#x3D; pNode-&gt;keyNum; ++i)\n\t\t\t\t\trecursive_clear(pNode-&gt;pChild[i]);\n\t\t\t&#125;\n\t\t\tdeleteNode(pNode);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;删除节点\n\tvoid deleteNode(Node *&amp;pNode)\n\t&#123;\n\t\tif (pNode !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete pNode;\n\t\t\tpNode &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;查找关键字\n\tbool search(Node *pNode, const T &amp;key)const\n\t&#123;\n\t\tif (pNode &#x3D;&#x3D; NULL)  &#x2F;&#x2F;检测节点指针是否为空，或该节点是否为叶子节点\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tint i;\n\t\t\tfor (i &#x3D; 0; i&lt;pNode-&gt;keyNum &amp;&amp; key&gt;*(pNode-&gt;keyValue + i); ++i)&#x2F;&#x2F;找到使key&lt;&#x3D;pNode-&gt;keyValue[i]成立的最小下标i\n\t\t\t&#123;\n\t\t\t&#125;\n\t\t\tif (i &lt; pNode-&gt;keyNum &amp;&amp; key &#x3D;&#x3D; pNode-&gt;keyValue[i])\n\t\t\t&#123;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tif (pNode-&gt;isLeaf)   &#x2F;&#x2F;检查该节点是否为叶子节点\n\t\t\t\t&#123;\n\t\t\t\t\treturn false;\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\treturn search(pNode-&gt;pChild[i], key);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;分裂子节点\n\tvoid splitChild(Node *pParent, int nChildIndex, Node *pChild)\n\t&#123;\n\t\t&#x2F;&#x2F;将pChild分裂成pLeftNode和pChild两个节点\n\t\t&#x2F;&#x2F;分裂后的右节点\n\t\t&#x2F;&#x2F;初始化右节点\n\t\tNode *pRightNode &#x3D; new Node();\n\t\tpRightNode-&gt;isLeaf &#x3D; pChild-&gt;isLeaf;\n\t\tpRightNode-&gt;keyNum &#x3D; KEY_MIN;\n\t\tint i;\n\t\t&#x2F;&#x2F;拷贝关键字的值\n\t\tfor (i &#x3D; 0; i &lt; KEY_MIN; ++i)\n\t\t&#123;\n\t\t\tpRightNode-&gt;keyValue[i] &#x3D; pChild-&gt;keyValue[i + CHILD_MIN];&#x2F;&#x2F;从i + CHILD_MIN开始拷贝，给左孩子留下最少CHILD_MIN个关键字\n\t\t&#125;\n\t\t&#x2F;&#x2F;如果不是叶子节点，拷贝孩子节点指针\n\t\tif (!pChild-&gt;isLeaf)  \n\t\t&#123;\n\t\t\tfor (i &#x3D; 0; i &lt; CHILD_MIN; ++i)\n\t\t\t&#123;\n\t\t\t\tpRightNode-&gt;pChild[i] &#x3D; pChild-&gt;pChild[i + CHILD_MIN];\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tpChild-&gt;keyNum &#x3D; KEY_MIN;  &#x2F;&#x2F;更新左子树的关键字个数\n\n\t\tfor (i &#x3D; pParent-&gt;keyNum; i &gt; nChildIndex; --i)&#x2F;&#x2F;将父节点中的nChildIndex后的所有关键字的值和子树指针向后移一位\n\t\t&#123;\n\t\t\tpParent-&gt;pChild[i + 1] &#x3D; pParent-&gt;pChild[i];\n\t\t\tpParent-&gt;keyValue[i] &#x3D; pParent-&gt;keyValue[i - 1];\n\t\t&#125;\n\t\t++pParent-&gt;keyNum;  &#x2F;&#x2F;更新父节点的关键字个数\n\t\tpParent-&gt;pChild[nChildIndex + 1] &#x3D; pRightNode;  &#x2F;&#x2F;存储右子树指针\n\t\tpParent-&gt;keyValue[nChildIndex] &#x3D; pChild-&gt;keyValue[KEY_MIN];&#x2F;&#x2F;把节点的中间值提到父节点\n\t&#125;\n\n\t&#x2F;&#x2F;在非满节点中插入关键字\n\tvoid insertNonFull(Node *pNode, const T &amp;key)\n\t&#123;\n\t\tint i &#x3D; pNode-&gt;keyNum;  &#x2F;&#x2F;获取节点内关键字个数\n\t\tif (pNode-&gt;isLeaf)      &#x2F;&#x2F;pNode是叶子节点\n\t\t&#123;\n\t\t\twhile (i &gt; 0 &amp;&amp; key &lt; pNode-&gt;keyValue[i - 1])   &#x2F;&#x2F;从后往前，查找关键字的插入位置\n\t\t\t&#123;\n\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pNode-&gt;keyValue[i - 1];  &#x2F;&#x2F;向后移位\n\t\t\t\t--i;\n\t\t\t&#125;\n\t\t\tpNode-&gt;keyValue[i] &#x3D; key;  &#x2F;&#x2F;插入关键字的值\n\t\t\t++pNode-&gt;keyNum; &#x2F;&#x2F;更新节点关键字的个数\n\t\t&#125;\n\t\telse&#x2F;&#x2F;pNode是内节点\n\t\t&#123;\n\t\t\twhile (i &gt; 0 &amp;&amp; key &lt; pNode-&gt;keyValue[i - 1])   &#x2F;&#x2F;从后往前，查找关键字的插入的子树\n\t\t\t\t--i;\n\t\t\tNode *pChild &#x3D; pNode-&gt;pChild[i];  &#x2F;&#x2F;目标子树结点指针 \n\t\t\tif (pChild-&gt;keyNum &#x3D;&#x3D; KEY_MAX)  &#x2F;&#x2F;子树节点已满\n\t\t\t&#123;\n\t\t\t\tsplitChild(pNode, i, pChild);&#x2F;&#x2F;分裂子树节点\n\t\t\t\tif (key &gt; pNode-&gt;keyValue[i])   &#x2F;&#x2F;确定目标子树\n\t\t\t\t\tpChild &#x3D; pNode-&gt;pChild[i + 1];\n\t\t\t&#125;\n\t\t\tinsertNonFull(pChild, key);  &#x2F;&#x2F;插入关键字到目标子树节点\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;用括号打印树\n\tvoid displayInConcavo(Node *pNode, int count)const\n\t&#123;\n\t\tif (pNode !&#x3D; NULL)\n\t\t&#123;\n\t\t\tint i, j;\n\t\t\tfor (i &#x3D; 0; i &lt; pNode-&gt;keyNum; ++i)\n\t\t\t&#123;\n\t\t\t\tif (!pNode-&gt;isLeaf)\n\t\t\t\t&#123;\n\t\t\t\t\tdisplayInConcavo(pNode-&gt;pChild[i], count - 2);\n\t\t\t\t&#125;\n\t\t\t\tfor (j &#x3D; count; j &gt;&#x3D; 0; --j)\n\t\t\t\t&#123;\n\t\t\t\t\tcout &lt;&lt; &quot;-&quot;;\n\t\t\t\t&#125;\n\t\t\t\tcout &lt;&lt; pNode-&gt;keyValue[i] &lt;&lt; endl;\n\t\t\t&#125;\n\t\t\tif (!pNode-&gt;isLeaf)\n\t\t\t&#123;\n\t\t\t\tdisplayInConcavo(pNode-&gt;pChild[i], count - 2);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;合并两个子节点\n\tvoid mergeChild(Node *pParent, int index)\n\t&#123;\n\t\tNode *pChild1 &#x3D; pParent-&gt;pChild[index];\n\t\tNode *pChild2 &#x3D; pParent-&gt;pChild[index + 1];\n\t\t&#x2F;&#x2F;将pChild2数据合并到pChild1\n\t\tpChild1-&gt;keyNum &#x3D; KEY_MAX;\n\t\tpChild1-&gt;keyValue[KEY_MIN] &#x3D; pParent-&gt;keyValue[index];&#x2F;&#x2F;将父节点index的值下移\n\t\tint i;\n\t\tfor (i &#x3D; 0; i &lt; KEY_MIN; ++i)\n\t\t&#123;\n\t\t\tpChild1-&gt;keyValue[i + KEY_MIN + 1] &#x3D; pChild2-&gt;keyValue[i];\n\t\t&#125;\n\t\tif (!pChild1-&gt;isLeaf)\n\t\t&#123;\n\t\t\tfor (i &#x3D; 0; i &lt; CHILD_MIN; ++i)\n\t\t\t&#123;\n\t\t\t\tpChild1-&gt;pChild[i + CHILD_MIN] &#x3D; pChild2-&gt;pChild[i];\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;父节点删除index的key，index后的往前移一位\n\t\t--pParent-&gt;keyNum;\n\t\tfor (i &#x3D; index; i &lt; pParent-&gt;keyNum; ++i)\n\t\t&#123;\n\t\t\tpParent-&gt;keyValue[i] &#x3D; pParent-&gt;keyValue[i + 1];\n\t\t\tpParent-&gt;pChild[i + 1] &#x3D; pParent-&gt;pChild[i + 2];\n\t\t&#125;\n\t\tdeleteNode(pChild2);  &#x2F;&#x2F;删除pChild2\n\t&#125;\n\n\t&#x2F;&#x2F;递归的删除关键字\n\tvoid recursive_remove(Node *pNode, const T &amp;key)\n\t&#123;\n\t\tint i &#x3D; 0;\n\t\twhile (i&lt;pNode-&gt;keyNum&amp;&amp;key&gt;pNode-&gt;keyValue[i])\n\t\t\t++i;\n\t\tif (i &lt; pNode-&gt;keyNum&amp;&amp;key &#x3D;&#x3D; pNode-&gt;keyValue[i])&#x2F;&#x2F;关键字key在节点pNode中\n\t\t&#123;\n\t\t\tif (pNode-&gt;isLeaf)&#x2F;&#x2F;pNode是个叶节点\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;从pNode中删除k\n\t\t\t\t--pNode-&gt;keyNum;\n\t\t\t\tfor (; i &lt; pNode-&gt;keyNum; ++i)\n\t\t\t\t&#123;\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pNode-&gt;keyValue[i + 1];\n\t\t\t\t&#125;\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t\telse&#x2F;&#x2F;pNode是个内节点\n\t\t\t&#123;\n\t\t\t\tNode *pChildPrev &#x3D; pNode-&gt;pChild[i];&#x2F;&#x2F;节点pNode中前于key的子节点\n\t\t\t\tNode *pChildNext &#x3D; pNode-&gt;pChild[i + 1];&#x2F;&#x2F;节点pNode中后于key的子节点\n\t\t\t\tif (pChildPrev-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;节点pChildPrev中至少包含CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\tT prevKey &#x3D; getPredecessor(pChildPrev); &#x2F;&#x2F;获取key的前驱关键字\n\t\t\t\t\trecursive_remove(pChildPrev, prevKey);\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; prevKey;     &#x2F;&#x2F;替换成key的前驱关键字\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t\telse if (pChildNext-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;节点pChildNext中至少包含CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\tT nextKey &#x3D; getSuccessor(pChildNext); &#x2F;&#x2F;获取key的后继关键字\n\t\t\t\t\trecursive_remove(pChildNext, nextKey);\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; nextKey;     &#x2F;&#x2F;替换成key的后继关键字\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t\telse&#x2F;&#x2F;节点pChildPrev和pChildNext中都只包含CHILD_MIN-1个关键字\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(pNode, i);\n\t\t\t\t\trecursive_remove(pChildPrev, key);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse&#x2F;&#x2F;关键字key不在节点pNode中\n\t\t&#123;\n\t\t\tNode *pChildNode &#x3D; pNode-&gt;pChild[i];&#x2F;&#x2F;包含key的子树根节点\n\t\t\tif (pChildNode-&gt;keyNum &#x3D;&#x3D; KEY_MIN)&#x2F;&#x2F;只有t-1个关键字\n\t\t\t&#123;\n\t\t\t\tNode *pLeft &#x3D; i &gt; 0 ? pNode-&gt;pChild[i - 1] : NULL;  &#x2F;&#x2F;左兄弟节点\n\t\t\t\tNode *pRight &#x3D; i &lt; pNode-&gt;keyNum ? pNode-&gt;pChild[i + 1] : NULL;&#x2F;&#x2F;右兄弟节点\n\t\t\t\tint j;\n\t\t\t\tif (pLeft&amp;&amp;pLeft-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;左兄弟节点至少有CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;父节点中i-1的关键字下移至pChildNode中\n\t\t\t\t\tfor (j &#x3D; pChildNode-&gt;keyNum; j &gt; 0; --j)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpChildNode-&gt;keyValue[j] &#x3D; pChildNode-&gt;keyValue[j - 1];\n\t\t\t\t\t&#125;\n\t\t\t\t\tpChildNode-&gt;keyValue[0] &#x3D; pNode-&gt;keyValue[i - 1];\n\n\t\t\t\t\tif (!pLeft-&gt;isLeaf)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tfor (j &#x3D; pChildNode-&gt;keyNum + 1; j &gt; 0; --j) &#x2F;&#x2F;pLeft节点中合适的子女指针移植到pChildNode中\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tpChildNode-&gt;pChild[j] &#x3D; pChildNode-&gt;pChild[j - 1];\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tpChildNode-&gt;pChild[0] &#x3D; pLeft-&gt;pChild[pLeft-&gt;keyNum];\n\t\t\t\t\t&#125;\n\t\t\t\t\t++pChildNode-&gt;keyNum;\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pLeft-&gt;keyValue[pLeft-&gt;keyNum - 1];&#x2F;&#x2F;pLeft节点中的最大关键字上升到pNode中\n\t\t\t\t\t--pLeft-&gt;keyNum;\n\t\t\t\t&#125;\n\t\t\t\telse if (pRight&amp;&amp;pRight-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;右兄弟节点至少有CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;父节点中i的关键字下移至pChildNode中\n\t\t\t\t\tpChildNode-&gt;keyValue[pChildNode-&gt;keyNum] &#x3D; pNode-&gt;keyValue[i];\n\t\t\t\t\t++pChildNode-&gt;keyNum;\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pRight-&gt;keyValue[0];&#x2F;&#x2F;pRight节点中的最小关键字上升到pNode中\n\t\t\t\t\t--pRight-&gt;keyNum;\n\t\t\t\t\tfor (j &#x3D; 0; j &lt; pRight-&gt;keyNum; ++j)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpRight-&gt;keyValue[j] &#x3D; pRight-&gt;keyValue[j + 1];\n\t\t\t\t\t&#125;\n\t\t\t\t\tif (!pRight-&gt;isLeaf)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpChildNode-&gt;pChild[pChildNode-&gt;keyNum] &#x3D; pRight-&gt;pChild[0];&#x2F;&#x2F;pRight节点中合适的子女指针移植到pChildNode中\n\t\t\t\t\t\tfor (j &#x3D; 0; j &lt;&#x3D; pRight-&gt;keyNum; ++j)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tpRight-&gt;pChild[j] &#x3D; pRight-&gt;pChild[j + 1];\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;左右兄弟节点都只包含CHILD_MIN-1个节点\n\t\t\t\telse if (pLeft)&#x2F;&#x2F;与左兄弟合并\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(pNode, i - 1);\n\t\t\t\t\tpChildNode &#x3D; pLeft;\n\t\t\t\t&#125;\n\t\t\t\telse if (pRight)&#x2F;&#x2F;与右兄弟合并\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(pNode, i);\n\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\trecursive_remove(pChildNode, key);\n\t\t&#125;\n\t&#125;\n\n\tT getPredecessor(Node *pNode)&#x2F;&#x2F;找到前驱关键字\n\t&#123;\n\t\twhile (!pNode-&gt;isLeaf)\n\t\t&#123;\n\t\t\tpNode &#x3D; pNode-&gt;pChild[pNode-&gt;keyNum];\n\t\t&#125;\n\t\treturn pNode-&gt;keyValue[pNode-&gt;keyNum - 1];\n\t&#125;\n\n\tT getSuccessor(Node *pNode)&#x2F;&#x2F;找到后继关键字\n\t&#123;\n\t\twhile (!pNode-&gt;isLeaf)\n\t\t&#123;\n\t\t\tpNode &#x3D; pNode-&gt;pChild[0];\n\t\t&#125;\n\t\treturn pNode-&gt;keyValue[0];\n\t&#125;\n\nprivate:\n\tNode * m_pRoot;  &#x2F;&#x2F;B树的根节点\n&#125;;\n\n</code></pre>\n\n<p>看看就好</p>\n<h3 id=\"b-树\"><a href=\"#b-树\" class=\"headerlink\" title=\"b+树\"></a>b+树</h3><h3 id=\"2-3树\"><a href=\"#2-3树\" class=\"headerlink\" title=\"2-3树\"></a>2-3树</h3><h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><h3 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h3><h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>将序列分成三部分：有序，待排元素，未排</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void insertSort(vector&lt;int&gt;&amp;nums)\n&#123;\n\tint len &#x3D;nums.size();\t\t\n\tint dummy &#x3D; 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;哨兵数，存放待排元素\n\tfor (int i &#x3D; 1; i &lt;len; i++)\n\t&#123;\n\t\tif (nums[i] &lt; nums[i - 1])\n\t\t&#123;\n\t\t\tdummy &#x3D; nums[i];\n\t\t\tfor (int j &#x3D; i - 1; dummy &lt; nums[j]; j--)\n\t\t\t&#123;\n\t\t\t\tnums[j + 1] &#x3D; nums[j];\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;后移\n\t\t\t&#125;\n\t\t\tnums[j + 1] &#x3D; dummy;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>时间复杂度：On^2</p>\n<p>空间复杂度：O1</p>\n<p>稳定排序</p>\n<p>适用情景：顺序存储与链式存储的线性表</p>\n<p>折半插入排序：定位元素位置的时候二分查找</p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void BubbleSort(vector&lt;int&gt;&amp;array)\n&#123;\n\tint len &#x3D; array.size();\n\t&#x2F;&#x2F;每一轮交换都能将一个最小的元素放到前面\n\tfor (int i &#x3D; 0; i &lt; len-1; i++)\n\t&#123;\n\t\tbool flag &#x3D; false;\n\t\tfor (int j &#x3D; len - 1; j &gt; i; j--)\n\t\t&#123;\n\t\t\tif (array[j - 1] &gt; array[j])\n\t\t\t&#123;\n\t\t\t\tswap(array[j - 1], array[j]);\n\t\t\t\tflag &#x3D; true;\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;如果本轮没有交换，则已经有序，后面不用再排\n\t\tif (!flag)\n\t\t&#123;\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>时间复杂度：On^2</p>\n<p>空间复杂度：O1</p>\n<p>稳定排序</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nint partition(vector&lt;int&gt;&amp;nums,int l,int r)\n&#123;\n\tint pivot &#x3D; nums[l];\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;基准元素，序列被划分成两部分，在其左边的小于基准元素，在右边的大于基准元素\n\twhile (l &lt; r)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;双指针\n\t&#123;\n\t\twhile (l &lt; r&amp;&amp;nums[r] &gt;&#x3D; pivot)\n\t\t&#123;\n\t\t\tr--;\n\t\t&#125;\n\t\tnums[l] &#x3D; nums[r];\n\t\twhile (l &lt; r&amp;&amp;nums[l] &lt;&#x3D; pivot)\n\t\t&#123;\n\t\t\tl++;\n\t\t&#125;\n\t\tnums[r] &#x3D; nums[l];\n\t&#125;\n\tnums[l] &#x3D; pivot;\n\treturn l;\n&#125;\n\nvoid quickSort(vector&lt;int&gt;&amp;nums,int l,int r)\n&#123;\n\tif (l &lt; r)\n\t&#123;\n\t\tint pivotpos &#x3D; partition(nums, l, r);\t\t\t\t\t\t\t\t&#x2F;&#x2F;递归切块排序\n\t\tquickSort(nums, l, pivotpos-1);\n\t\tquickSort(nums, pivotpos + 1, r);\n\t&#125;\n&#125;</code></pre>\n\n<p>时间复杂度：Onlogn</p>\n<p>空间复杂度：O1</p>\n<p>不稳定排序</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void SelectSort(vector&lt;int&gt;&amp;array)\n&#123;\n\tint len &#x3D; array.size();\n\tfor (int i &#x3D; 0; i &lt; len - 1; i++)\n\t&#123;\n\t\tint min&#x3D; i;\n\t\tfor (int j &#x3D; i + 1; j &lt; len; j++)\n\t\t&#123;\n\t\t\tif (array[j] &lt; array[min])min &#x3D; j;\n\t\t&#125;\n\t\tif (min !&#x3D; i)\n\t\t&#123;\n\t\t\tswap(array[i], array[min]);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>时间复杂度：On^2</p>\n<p>空间复杂度：O1</p>\n<p>不稳定排序</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvoid heapadjust(vector&lt;int&gt;&amp;store, int k,int len)\n&#123;\n\tstore[0] &#x3D; store[len];\n\tfor (int i &#x3D; 2 * k; i &lt;&#x3D; len; i*&#x3D;2)\n\t&#123;\n\t\tif (i &lt; len&amp;&amp;store[i] &lt; store[i + 1])\n\t\t\ti++;\n\t\tif (store[0] &gt; store[i])\n\t\t\tbreak;\n\t\telse\n\t\t&#123;\n\t\t\tstore[k] &#x3D; store[i];\n\t\t\tk &#x3D; i;\n\t\t&#125;\n\t&#125;\n\tstore[k] &#x3D; store[0];\n&#125;\n\nvoid buildMaxHeap(vector&lt;int&gt;&amp;store,int len)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len &#x2F; 2; i &gt; 0; i--)\n\t&#123;\n\t\theapadjust(store, i);\n\t&#125;\n&#125;\n\nvoid heapSort(vector&lt;int&gt;&amp;store)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len; i &gt;1; i--)\n\t&#123;\n\t\tswap(store[i], store[1]);\n\t\theapadjust(store, 1,i-1);\n\t&#125;\n&#125;</code></pre>\n\n<p>时间复杂度：Onlogn</p>\n<p>空间复杂度：O1</p>\n<p>不稳定排序</p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Merge(vector&lt;int&gt;&amp;array, int low, int mid, int high)\n&#123;\n\tvector&lt;int&gt;helper(array);\n\t&#x2F;&#x2F;将原数组分成两部分，i指向辅助数组第一部分，j指向辅助数组第二部分，k指向原数组，双指针填充原数组\n\tint i,j,k;\n\tfor (i &#x3D; low, j &#x3D; mid + 1, k &#x3D; i; i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high; k++)\n\t&#123;\n\t\tif (helper[i] &lt;&#x3D; helper[j])\n\t\t&#123;\n\t\t\tarray[k] &#x3D; helper[i++];\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tarray[k] &#x3D; helper[j++];\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;将未检测完的表填入\n\twhile (i &lt;&#x3D; mid)\n\t&#123;\n\t\tarray[k++] &#x3D; helper[i++];\n\t&#125;\n\twhile (j &lt;&#x3D; high)\n\t&#123;\n\t\tarray[k++] &#x3D; helper[j++];\n\t&#125;\n&#125;\n\nvoid MergeSort(vector&lt;int&gt;&amp;array, int low, int high)\n&#123;\n\tif (low &lt; high)\n\t&#123;\n\t\tint mid &#x3D; (low + high) &#x2F; 2;\n\t\tMergeSort(array, low, mid);\n\t\tMergeSort(array, mid+1, high);\n\t\tMerge(array, low, mid,high);\n\t&#125;\n&#125;</code></pre>\n\n<p>时间复杂度：Onlogn</p>\n<p>空间复杂度：On</p>\n<p>稳定排序</p>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><h2 id=\"算法核心思想\"><a href=\"#算法核心思想\" class=\"headerlink\" title=\"算法核心思想\"></a>算法核心思想</h2><h3 id=\"图-1\"><a href=\"#图-1\" class=\"headerlink\" title=\"图\"></a>图</h3><h4 id=\"快速建图\"><a href=\"#快速建图\" class=\"headerlink\" title=\"快速建图\"></a>快速建图</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h4 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h4><p><strong>kruskal</strong></p>\n<p>对边贪心</p>\n<p>1选一条最短的边加入集合</p>\n<p>2在剩余的边中选最短且不会形成回路的边加入集合</p>\n<p>3重复n-1次</p>\n<p><strong>prim</strong></p>\n<p>对点贪心</p>\n<p>1任取一点加入集合T</p>\n<p>2选择不在T中的且与T中点最近的点加入集合</p>\n<p>3重复n-1次</p>\n<p>例题kruskal</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class UnionFind\n&#123;\nprivate:\n    vector&lt;int&gt;parent;\npublic:\n    UnionFind(int n)\n    &#123;\n        parent.resize(n+1);\n        iota(parent.begin(),parent.end(),0);\n    &#125;\n\n    int find(int index)\n    &#123;\n        if(parent[index]&#x3D;&#x3D;index)\n        &#123;\n            return index;\n        &#125;\n        parent[index]&#x3D;find(parent[index]);\n        return parent[index];\n    &#125;\n\n    void Union(int m,int n)\n    &#123;\n        parent[find(m)]&#x3D;find(n);\n    &#125;\n\n&#125;;\n\nclass Solution &#123;\npublic:\n\n    int minimumCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) &#123;\n        &#x2F;&#x2F;对边排序\n        sort(connections.begin(),connections.end(),[](const std::vector&lt;int&gt;&amp; a, const std::vector&lt;int&gt;&amp; b) &#123;\n  return a[2] &lt; b[2];\n&#125;);\n\t\t\n        int m&#x3D;connections.size();\n        UnionFind uf(n);\n        int answer&#x3D;connections[0][2];\n        uf.Union(connections[0][0],connections[0][1]);\n        int cnt&#x3D;1;\n        for(int i&#x3D;1;i&lt;n-1;)\n        &#123;\n            if(cnt&#x3D;&#x3D;m)\n            &#123;\n                return -1;\n            &#125;\n            &#x2F;&#x2F;！！！\n            if(uf.find(connections[cnt][0])!&#x3D;uf.find(connections[cnt][1]))\n            &#123;\n                answer+&#x3D;connections[cnt][2];\n                uf.Union(connections[cnt][0],connections[cnt][1]);\n                i++;\n            &#125;\n            cnt++;\n        &#125;\n\n    return answer;\n\n    &#125;\n&#125;;</code></pre>\n\n<h4 id=\"最短路径-1\"><a href=\"#最短路径-1\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h4><p>Dijkstra</p>\n<p>1 从不在集合S中的顶点选择Dv最小的顶点v，将其放入集 合S；</p>\n<p>2 考察v的不在S中的邻接顶点w，若Dv+weight(v,w) &lt; Dw， 则更新Dw，使Dw&#x3D;Dv+weight(v,w) .</p>\n<p>3 重复① ② ，直至所有顶点都放入集合S。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n","text":"基本数据结构（code）链表单链表双链表循环链表静态链表前缀和一维：二维：哈希表class MyHashSet &#123; public: MyHashSet() &#123; this-&gt;bucket.resize(BUCKSIZE); &#125; int HashF...","link":"","photos":[],"count_time":{"symbolsCount":"69k","symbolsTime":"1:03"},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88code%EF%BC%89\"><span class=\"toc-text\">基本数据结构（code）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">循环链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">静态链表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BC%80%E5%92%8C\"><span class=\"toc-text\">前缀和</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%BB%B4%EF%BC%9A\"><span class=\"toc-text\">一维：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%EF%BC%9A\"><span class=\"toc-text\">二维：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E8%A1%A8\"><span class=\"toc-text\">哈希表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E9%98%9F%E5%88%97\"><span class=\"toc-text\">基本队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">双端队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">循环队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\"><span class=\"toc-text\">单调队列</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">链接</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC\"><span class=\"toc-text\">表达式求值</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88\"><span class=\"toc-text\">单调栈</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91\"><span class=\"toc-text\">树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91\"><span class=\"toc-text\">哈夫曼树</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#KMP\"><span class=\"toc-text\">KMP</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE\"><span class=\"toc-text\">图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">图的存储结构与遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">一些基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">存储结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">邻接矩阵</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%82%BB%E6%8E%A5%E8%A1%A8\"><span class=\"toc-text\">邻接表</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">图的遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-x2F-%E6%90%9C%E7%B4%A2-DFS-Depth-First-Search-DFS\"><span class=\"toc-text\">深度优先遍历&#x2F;搜索 DFS ( Depth First Search, DFS)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">广度优先遍历</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E9%81%8D%E5%8E%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">图遍历的应用举例</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">拓扑排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">关键概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%B4%A8\"><span class=\"toc-text\">性质</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">关键路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">关键概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">求关键路径算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">计算最短时间</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%80%E8%BF%9F%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">计算最迟发生时间</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%B1%82%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8\"><span class=\"toc-text\">求关键活动</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">主函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">最短路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E6%9D%83%E5%9B%BE%EF%BC%9A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">无权图：广度优先遍历</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Dijkstra\"><span class=\"toc-text\">Dijkstra</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Bellman-Ford\"><span class=\"toc-text\">Bellman-Ford</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SPFA\"><span class=\"toc-text\">SPFA</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#FLOYD\"><span class=\"toc-text\">FLOYD</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98Warshall%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">传递闭包问题Warshall算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%BC%8F\"><span class=\"toc-text\">变式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BB%A1%E8%B6%B3%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">满足约束的最短路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#K-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">K 站中转内最短路径</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E6%94%AF%E6%92%91%E6%A0%91\"><span class=\"toc-text\">最小支撑树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#kruskal\"><span class=\"toc-text\">kruskal</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#prim\"><span class=\"toc-text\">prim</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">容器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">二分查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">标准模板</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-while-%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%AD%E6%98%AF-lt-x3D-%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF-lt-%EF%BC%9F\"><span class=\"toc-text\">为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt; ？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E4%B8%BA%E4%BB%80%E4%B9%88-left-x3D-mid-1%EF%BC%8Cright-x3D-mid-1%EF%BC%9F%E6%88%91%E7%9C%8B%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF-right-x3D-mid-%E6%88%96%E8%80%85-left-x3D-mid%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%BF%99%E4%BA%9B%E5%8A%A0%E5%8A%A0%E5%87%8F%E5%87%8F%EF%BC%8C%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%EF%BC%9F\"><span class=\"toc-text\">2. 为什么 left &#x3D; mid + 1，right &#x3D; mid - 1？我看有的代码是 right &#x3D; mid 或者 left &#x3D; mid，没有这些加加减减，到底怎么回事，怎么判断？</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%A2%E8%93%9D%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">红蓝通用模板</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91\"><span class=\"toc-text\">二叉查找树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%B4%A8-1\"><span class=\"toc-text\">性质</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AVL%E6%A0%91\"><span class=\"toc-text\">AVL树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1\"><span class=\"toc-text\">代码实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b%E6%A0%91\"><span class=\"toc-text\">b树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%B4%A8-2\"><span class=\"toc-text\">性质</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">插入</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">删除</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\">代码实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E6%A0%91\"><span class=\"toc-text\">b+树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3%E6%A0%91\"><span class=\"toc-text\">2-3树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%A2%E9%BB%91%E6%A0%91\"><span class=\"toc-text\">红黑树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">散列表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">堆排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">基数排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">算法核心思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE-1\"><span class=\"toc-text\">图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E5%BB%BA%E5%9B%BE\"><span class=\"toc-text\">快速建图</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span class=\"toc-text\">最小生成树</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-1\"><span class=\"toc-text\">最短路径</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{}}