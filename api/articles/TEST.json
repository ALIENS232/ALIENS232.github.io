{"title":"TEST","uid":"ad07a23e70b0e9f11bd9b11c976479b5","slug":"TEST","date":"2022-12-27T09:02:26.000Z","updated":"2022-12-27T09:03:05.550Z","comments":true,"path":"api/articles/TEST.json","keywords":"博客","cover":null,"content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"设计模式简介\"><a href=\"#设计模式简介\" class=\"headerlink\" title=\"设计模式简介\"></a>设计模式简介</h2><p>可复用</p>\n<p>深入理解面向对象：</p>\n<p>​\t封装：隐藏内部实现</p>\n<p>​\t继承：复用现有代码</p>\n<p>​\t多态：改写对象行为</p>\n<p>面对变化：</p>\n<p>​\t分解：分治</p>\n<p>​\t抽象：处理泛化和理想化的模型</p>\n<h2 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h2><p>隔离变化：</p>\n<p>​\t面向对象能够将变化带来的影响减为最小</p>\n<p>各司其职：</p>\n<p>​\t新增变化导致的新类型不影响原来类型</p>\n<p>对象：</p>\n<p>​\t语言实现上封装了代码和数据</p>\n<p>​\t规格上是可以被使用的公共接口</p>\n<p>​\t概念上是拥有责任的抽象</p>\n<h3 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h3><h4 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h4><p>​\t高层（稳定）与低层（变化）模块互不依赖，二者都依赖于抽象（稳定）</p>\n<p>​\t实现细节（变化）依赖于抽象（稳定）</p>\n<h4 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h4><p>​\t对扩展开放，对修改封闭</p>\n<p>​\t类模块可以扩展，不能修改</p>\n<h4 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h4><p>​\t一个类仅有一个引起他变化的原因</p>\n<p>​\t变化的方向隐含类的责任</p>\n<h4 id=\"替换原则\"><a href=\"#替换原则\" class=\"headerlink\" title=\"替换原则\"></a>替换原则</h4><p>​\t子类能够替换成它们的基类（is a）</p>\n<p>​\t继承表达类型抽象</p>\n<h4 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h4><p>​\t接口小而完备</p>\n<p>​\t客户程序不使用它们不需要的接口</p>\n<h4 id=\"优先使用对象组合，而不是类继承\"><a href=\"#优先使用对象组合，而不是类继承\" class=\"headerlink\" title=\"优先使用对象组合，而不是类继承\"></a>优先使用对象组合，而不是类继承</h4><p>​\t黑箱，白箱</p>\n<p>​\t继承某种程度是破坏了封装性，父类对子类透明</p>\n<p>​\t对象组合要求对象有良好定义的接口</p>\n<h4 id=\"针对接口编程，而不是针对实现编程\"><a href=\"#针对接口编程，而不是针对实现编程\" class=\"headerlink\" title=\"针对接口编程，而不是针对实现编程\"></a>针对接口编程，而不是针对实现编程</h4><p>​\t不将变量类型声明为某个特定的具体类，而是声明为某个接口</p>\n<p>​\t客户无需知道对象的具体类型，而要知道对象的所有接口</p>\n","text":"设计模式设计模式简介可复用 深入理解面向对象： ​ 封装：隐藏内部实现 ​ 继承：复用现有代码 ​ 多态：改写对象行为 面对变化： ​ 分解：分治 ​ 抽象：处理泛化和理想化的模型 面向对象设计原则隔离变化： ​ 面向对象能够将变化带来的影响减为最小 各司其职： ​ 新增变化导致...","link":"","photos":[],"count_time":{"symbolsCount":550,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">设计模式简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">面向对象设计原则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">设计原则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">依赖倒置原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">开放封闭原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">单一职责原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">替换原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">接口隔离原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%B1%BB%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">优先使用对象组合，而不是类继承</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%92%88%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E9%92%88%E5%AF%B9%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">针对接口编程，而不是针对实现编程</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{}}