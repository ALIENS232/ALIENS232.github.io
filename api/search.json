[{"id":"81579b6c641dedc829a2b0058112fc0c","title":"数据结构","content":"基本数据结构（code）链表单链表双链表循环链表静态链表前缀和一维：二维：哈希表class MyHashSet &#123;\npublic:\n    MyHashSet() &#123;\n        this-&gt;bucket.resize(BUCKSIZE);\n    &#125;\n\n    int HashFunc(int key)&#123;\n        return key % this-&gt;M;\n    &#125;\n\n    void add(int key) &#123;\n        int loc &#x3D; HashFunc(key);\n        if(!this-&gt;Search4Key(key))&#123;\n            (this-&gt;bucket)[loc].push_back(key);\n        &#125;\n    &#125;\n    \n    void remove(int key) &#123;\n        int loc &#x3D; HashFunc(key);\n        if(this-&gt;Search4Key(key))&#123;\n            for(vector&lt;int&gt;::iterator it&#x3D;(this-&gt;bucket)[loc].begin(); \n                it!&#x3D;(this-&gt;bucket)[loc].end(); it++)&#123;\n                    if(*it &#x3D;&#x3D; key)&#123;\n                        this-&gt;bucket[loc].erase(it);\n                        break;\n                    &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    bool contains(int key) &#123;\n        return this-&gt;Search4Key(key);\n    &#125;\n\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; bucket;\n    const int M &#x3D; 1000;\n    const int BUCKSIZE &#x3D; 1000;\n\n    int BinarySearch(vector&lt;int&gt;&amp; v, int target)&#123;\n        sort(v.begin(), v.end());\n        int left &#x3D; 0, right &#x3D; v.size()-1;\n        int loc &#x3D; -1;\n\n        while(left &lt;&#x3D; right)&#123;\n            int mid &#x3D; (left + right) % 2 &#x3D;&#x3D; 0 ? (left + right) &#x2F; 2: (left + right) &#x2F; 2 + 1;\n            eif(v[mid] &#x3D;&#x3D; target)&#123;\n                loc &#x3D; mid;\n                break;\n            &#125;else if(v[mid] &lt; target)&#123;\n                left &#x3D; mid + 1;\n            &#125;else&#123;\n                right &#x3D; mid - 1;\n            &#125;\n        &#125;\n\n        return loc;\n    &#125;\n\n    bool Search4Key(int key)&#123;\n        bool canget &#x3D; false;\n        int loc &#x3D; HashFunc(key);\n        if( this-&gt;BinarySearch(bucket[loc], key) !&#x3D; -1 )&#123;\n            canget &#x3D; true;\n        &#125;\n\n        return canget;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj &#x3D; new MyHashSet();\n * obj-&gt;add(key);\n * obj-&gt;remove(key);\n * bool param_3 &#x3D; obj-&gt;contains(key);\n *&#x2F;\n\n\n队列基本队列双端队列循环队列单调队列栈存储数组class Stack\n&#123;\nprivate:\n\tT A[MaxSize];\n\tint top &#x3D; -1;\npublic:\n\tbool empty()\n\t&#123;\n\t\treturn top &#x3D;&#x3D; -1;\n\t&#125;\n\n\tbool full()\n\t&#123;\n\t\treturn top &#x3D;&#x3D; MaxSize - 1;\n\t&#125;\n\n\tvoid push(T item)\n\t&#123;\n\t\tA[++top] &#x3D; item;\n\t&#125;\n\n\tT pop()\n\t&#123;\n\t\treturn A[top--];\n\t&#125;\n\n\tT top()\n\t&#123;\n\t\treturn A[top];\n\t&#125;\n&#125;;\n\n链接&#x2F;&#x2F;链栈\ntemplate&lt;typename T&gt;\nclass link_stack\n&#123;\n\npublic:\n\tclass stack_node\n\t&#123;\n\tpublic:\n\t\tstack_node*next;\n\t\tstack_node*pre;\n\t\tT val;\n\t\tstack_node(T val)\n\t\t&#123;\n\t\t\tnext &#x3D; nullptr;\n\t\t\tpre &#x3D; nullptr;\n\t\t\tthis-&gt;val &#x3D; val;\n\t\t&#125;\n\t&#125;;\nprivate:\n\tstack_node*top_ptr;\n\tint size &#x3D; 0;\npublic:\n\tlink_stack()\n\t&#123;\n\t\ttop_ptr &#x3D; nullptr;\n\t&#125;\n\n\tvoid push(T val)\n\t&#123;\n\t\tstack_node*new_node &#x3D; new stack_node(val);\n\t\tif (top_ptr)\n\t\t&#123;\n\t\t\ttop_ptr-&gt;next &#x3D; new_node;\n\t\t&#125;\n\t\tnew_node-&gt;pre &#x3D; top_ptr;\n\t\ttop_ptr &#x3D; new_node;\n\t&#125;\n\n\tT pop()\n\t&#123;\n\t\tif (empty())\n\t\t&#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\tT temp &#x3D; top_ptr-&gt;val;\n\t\tstack_node*to_del &#x3D; top_ptr;\n\t\ttop_ptr &#x3D; top_ptr-&gt;pre;\n\t\tdelete(to_del);\n\t\treturn temp;\n\t&#125;\n\n\tT top()\n\t&#123;\n\t\tif (empty())\n\t\t&#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn top_ptr-&gt;val;\n\t&#125;\n\n\tbool empty()\n\t&#123;\n\t\treturn top_ptr &#x3D;&#x3D; nullptr;\n\t&#125;\n\n&#125;;\n\n\n应用表达式求值单调栈树二叉树template&lt;typename T&gt;\nclass Tree\n&#123;\npublic:\n\tclass TreeNode\n\t&#123;\n\tpublic:\n\t\tTreeNode*right;\n\t\tTreeNode*left;\n\t\tT val;\n\t\tTreeNode(T val)\n\t\t&#123;\n\t\t\tright &#x3D; nullptr;\n\t\t\tleft &#x3D; nullptr;\n\t\t\tthis-&gt;val &#x3D; val;\n\t\t&#125;\n\t&#125;;\npublic:\n\tTreeNode*root;\n\tT null_mark;\n\tint num &#x3D; 0;\n\tTree(T mark)\n\t&#123;\n\t\tnull_mark &#x3D; mark;\n\t\troot &#x3D; build();\n\t&#125;\n\n\tTreeNode* build()\n\t&#123;\n        cin&gt;&gt;num;\n\t\tif (num &#x3D;&#x3D; null_mark)\n\t\t&#123;\n\t\t\treturn nullptr;\n\t\t&#125;\n\n\n\t\tTreeNode*cur_node &#x3D; new TreeNode(num);\n\t\tcur_node-&gt;left &#x3D; build();\n\t\tcur_node-&gt;right &#x3D; build();\n\t\treturn cur_node;\n\t&#125;\n\n\tvoid forward_travel(TreeNode*root)\n\t&#123;\n\t\tlink_stack&lt;TreeNode*&gt;ls;\n\t\tTreeNode*node &#x3D; root;\n\t\twhile (true)\n\t\t&#123;\n\t\t\twhile (node !&#x3D; nullptr)\n\t\t\t&#123;\n                cout &lt;&lt; node-&gt;val&lt;&lt;&#39; &#39;;\n\t\t\t\tls.push(node);\n\t\t\t\tnode &#x3D; node-&gt;left;\n\t\t\t&#125;\n\t\t\tif (!ls.empty())\n\t\t\t&#123;\n\t\t\t\tnode &#x3D; ls.pop();\n\t\t\t\t\n\t\t\t\tnode &#x3D; node-&gt;right;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn;\n\t&#125;\n\n\tvoid midward_travel(TreeNode*root)\n\t&#123;\n\t\tlink_stack&lt;TreeNode*&gt;ls;\n\t\tTreeNode*node &#x3D; root;\n\t\twhile (true)\n\t\t&#123;\n\t\t\twhile (node !&#x3D; nullptr)\n\t\t\t&#123;\n\t\t\t\tls.push(node);\n\t\t\t\tnode &#x3D; node-&gt;left;\n\t\t\t&#125;\n\t\t\tif (!ls.empty())\n\t\t\t&#123;\n\t\t\t\tnode &#x3D; ls.pop();\n\t\t\t\tcout &lt;&lt; node-&gt;val&lt;&lt;&#39; &#39;;\n\t\t\t\tnode &#x3D; node-&gt;right;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn;\n\t&#125;\n\n\tvoid backward_travel(TreeNode*root)\n\t&#123;\n\t\tif (!root)\n\t\t&#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tbackward_travel(root-&gt;left);\n\t\tbackward_travel(root-&gt;right);\n\t\tcout &lt;&lt; root-&gt;val &lt;&lt; &#39; &#39;;\n\t\treturn;\n\t&#125;\n&#125;;\n\n哈夫曼树class HuffmanTree\n&#123;\npublic:\n\tclass Node\n\t&#123;\n\tpublic:\n\t\tchar data;\n\t\tint weight;\n\t\tNode*left;\n\t\tNode*right;\n\t\tNode()\n\t\t&#123;\n\t\t\tweight &#x3D; 0;\n\t\t\tdata &#x3D; 0;\n\t\t\tleft &#x3D; right &#x3D; nullptr;\n\t\t&#125;\n\t&#125;;\n\n\tint N;&#x2F;&#x2F;节点个数（不同的字符个数）\n\tchar*ch;\n\tint*freq;\n\tNode*H;\n\tint WPL&#x3D;0;\n\tNode*root;\n\n\tHuffmanTree()\n\t&#123;\n\t\tch &#x3D; new char[N];\n\t\tfreq &#x3D; new int[N];\n\t\tH &#x3D; new Node[N];\n\t\tfor (int i &#x3D; 0; i &lt; N; i++)\n\t\t&#123;\n\t\t\tH[i].data &#x3D; ch[i];\n\t\t\tH[i].weight &#x3D; freq[i];\n\t\t&#125;\n\t\t&#x2F;&#x2F;排序，未实现\n\t\tHsort();\n\n\t\tfor (int i &#x3D; 0; i &lt; N - 1; i++)\n\t\t&#123;\n\t\t\tNode*t &#x3D; new Node;\n\t\t\tt-&gt;weight &#x3D; H[i].weight + H[i + 1].weight;\n\t\t\tWPL+&#x3D; t-&gt;weight;\n\t\t\tt-&gt;left &#x3D; &amp;H[i];\n\t\t\tt-&gt;right &#x3D; &amp;H[i + 1];\n\t\t\tt-&gt;data &#x3D; &#39; &#39;;\n\t\t\tint j &#x3D; i + 2;\n\t\t\twhile (j&lt;N&amp;&amp;t-&gt;weight&gt;H[j].weight)\n\t\t\t&#123;\n\t\t\t\tH[j - 1] &#x3D; H[j];\n\t\t\t&#125;\n\t\t\tH[j - 1] &#x3D; *t;\n\t\t&#125;\n\t\troot &#x3D; &amp;H[N - 1];\n\t&#125;\n\n\n\tvoid Hsort()\n\t&#123;\n\n\t&#125;\n\n\t~HuffmanTree()\n\t&#123;\n\t\tdelete[]ch;\n\t\tdelete[]freq;\n\t\tdelete[]H;\n\t&#125;\n\n&#125;;\n\n\n\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nclass huffman\n&#123;\npublic:\n\tclass TreeNode\n\t&#123;\n\tpublic:\n\t\tchar ch&#x3D;&#39; &#39;;\n\t\tint weight;\n\t\tstring str&#x3D;&quot;&quot;;\n\t\tTreeNode*left;\n\t\tTreeNode*right;\n\t\tTreeNode(char c)\n\t\t&#123;\n\t\t\tleft &#x3D; right &#x3D; nullptr;\n\t\t\tch &#x3D; c;\n\t\t\tweight &#x3D; 0;\n\t\t&#125;\n\t&#125;;\n\n\t&#x2F;&#x2F;次数数组\n\tint times[26];\n\t&#x2F;&#x2F;节点数组\n\tTreeNode* node[26];\n\t&#x2F;&#x2F;输出用的数组\n\tstring out[26];\n\t&#x2F;&#x2F;标记数组\n\tbool mark[26];\n\tint mark_sequence[26];\n\tstring s;\n\thuffman()\n\t&#123;\n\t\tcin &gt;&gt; s;\n\n\t\tint length &#x3D; s.size();\n\t\t&#x2F;&#x2F;初始化\n\t\tmemset(times, 0, sizeof(times));\n\t\tmemset(node, 0, sizeof(node));\n\t\tmemset(mark, 0, sizeof(mark));\n\t\tmemset(mark_sequence, 0, sizeof(mark_sequence));\n\t\t&#x2F;&#x2F;统计次数\n\t\tint temp_index &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; length; i++)\n\t\t&#123;\n\t\t\ttimes[s[i] - &#39;a&#39;]++;\n\t\t\tif (mark[s[i]-&#39;a&#39;] &#x3D;&#x3D; 0)\n\t\t\t&#123;\n\t\t\t\tnode[temp_index] &#x3D; new TreeNode(s[i]);\n\t\t\t\tmark[s[i] - &#39;a&#39;] &#x3D; 1;\n\t\t\t\tmark_sequence[temp_index] &#x3D; s[i] - &#39;a&#39;;\n\t\t\t\ttemp_index++;\n\t\t\t&#125;\n\t\t&#125;\n\n\n\t\tmemset(mark, 0, sizeof(mark));\n\t\t&#x2F;&#x2F;tempindex就是出现的不同的字母的个数\n\t\tfor (int i &#x3D; 0; i &lt; temp_index; i++)\n\t\t&#123;\n\t\t\tnode[i]-&gt;weight &#x3D; times[node[i]-&gt;ch - &#39;a&#39;];\n\t\t&#125;\n\n\t\tfor (int i &#x3D; 0; i &lt; temp_index-1; i++)\n\t\t&#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; temp_index - i - 1; j++)\n\t\t\t&#123;\n\t\t\t\tif (node[i]-&gt;weight &gt; node[i + 1]-&gt;weight)\n\t\t\t\t&#123;\n\t\t\t\t\tTreeNode*temp &#x3D; node[i];\n\t\t\t\t\tnode[i] &#x3D; node[i + 1];\n\t\t\t\t\tnode[i + 1] &#x3D; temp;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tTreeNode*root&#x3D;CreatHuffanmanTree(temp_index);\n\n\t\tforward(root,&quot;&quot;);\n\n\t\tprint_code(temp_index);\n\n\t\tdecode(root);\n\t\tdecode(root);\n\t&#125;\n\n\tTreeNode*CreatHuffanmanTree(int num)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; num-1; i++)\n\t\t&#123;\n\t\t\tTreeNode*t &#x3D; new TreeNode(&#39;,&#39;);\n\t\t\tt-&gt;weight &#x3D; node[i]-&gt;weight + node[i + 1]-&gt;weight;\n\n\t\t\tt-&gt;left &#x3D; node[i];\n\t\t\tt-&gt;right &#x3D; node[i + 1];\n\t\t\tint j &#x3D; i + 2;\n\t\t\twhile (j&lt;num &amp;&amp; t-&gt;weight&gt;&#x3D;node[j]-&gt;weight) &#123;\n\t\t\t\tnode[j - 1] &#x3D; node[j]; j++;\n\t\t\t&#125;\n\t\t\tnode[j - 1] &#x3D; t;\n\t\t&#125;\n\t\treturn node[num - 1];\n\t&#125;\n\n\tvoid forward(TreeNode*root,string s)\n\t&#123;\n\t\tif (!root-&gt;left&amp;&amp;!root-&gt;right)\n\t\t&#123;\n\t\t\tout[root-&gt;ch - &#39;a&#39;] &#x3D;root-&gt;str ;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (root-&gt;left)\n\t\t&#123;\n\t\t\troot-&gt;left-&gt;str&#x3D;s+&#39;0&#39;;\n\t\t\tforward(root-&gt;left,root-&gt;left-&gt;str);\n\t\t&#125;\n\t\tif (root-&gt;right)\n\t\t&#123;\n\t\t\troot-&gt;right-&gt;str&#x3D;s+&#39;1&#39;;\n\t\t\tforward(root-&gt;right,root-&gt;right-&gt;str);\n\t\t&#125;\n\t&#125;\n\n\tvoid print_code(int num)\n\t&#123;\n\t\tint count &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; s.size(); i++)\n\t\t&#123;\n\t\t\tcount +&#x3D; out[s[i]-&#39;a&#39;].size();\n\t\t&#125;\n\t\tcount &#x3D; count % 8 &#x3D;&#x3D; 0 ? count &#x2F; 8 : count &#x2F; 8+1;\n\t\tcout &lt;&lt; s.size() &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl;\n\t\tfor (int i &#x3D; 0; i &lt; num; i++)\n\t\t&#123;\n\t\t\tchar ch &#x3D; mark_sequence[i] + &#39;a&#39;;\n\t\t\tcout &lt;&lt; ch &lt;&lt; &quot;:&quot; &lt;&lt; out[mark_sequence[i]] &lt;&lt; endl;\n\t\t\t\n\t\t&#125;\n\t&#125;\n\n\tvoid decode(TreeNode*root)\n\t&#123;\n\t\ts &#x3D; &quot;&quot;;\n\t\tstring ans;\n\n\t\tcin &gt;&gt; s;\n\n\t\tint code_length &#x3D; s.size();\n\t\tint code_index &#x3D; 0;\n\t\tbool flag &#x3D; true;\n\t\twhile (code_index &lt; code_length)\n\t\t&#123;\n\t\t\tTreeNode*node &#x3D; root;\n\t\t\twhile (node)\n\t\t\t&#123;\n\t\t\t\tif ((node-&gt;left || node-&gt;right) &amp;&amp; code_length &#x3D;&#x3D; code_index)\n\t\t\t\t&#123;\n\t\t\t\t\tcout &lt;&lt; &quot;INVALID&quot; &lt;&lt; endl;\n\t\t\t\t\tflag &#x3D; false;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tif (!node-&gt;left &amp;&amp; !node-&gt;right)\n\t\t\t\t&#123;\n\t\t\t\t\tans +&#x3D; node-&gt;ch;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tif (s[code_index] &#x3D;&#x3D; &#39;0&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tnode &#x3D; node-&gt;left;\n\t\t\t\t\tcode_index++;\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\tnode &#x3D; node-&gt;right;\n\t\t\t\t\tcode_index++;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (flag)\n\t\t&#123;\n\t\t\tcout &lt;&lt; ans;\n\t\t&#125;\n\n\n\t&#125;\n\n&#125;;\n\nint main()\n&#123;\n\thuffman hf;\n\treturn 0;\n&#125;\n\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nclass Tree\n&#123;\npublic:\n\tclass TreeNode\n\t&#123;\n\tpublic:\n\t\tTreeNode*right;\n\t\tTreeNode*left;\n\t\tT val;\n\t\tTreeNode(T val)\n\t\t&#123;\n\t\t\tright &#x3D; nullptr;\n\t\t\tleft &#x3D; nullptr;\n\t\t\tthis-&gt;val &#x3D; val;\n\t\t&#125;\n\t&#125;;\npublic:\n\tTreeNode*root;\n\tT null_mark;\n    TreeNode* parent&#x3D;nullptr;\n\tint num &#x3D; 0;\n\tTree(T mark)\n\t&#123;\n\t\tnull_mark &#x3D; mark;\n\t\troot &#x3D; build();\n\t&#125;\n\n\tTreeNode* build()\n\t&#123;\n        cin&gt;&gt;num;\n\t\tif (num &#x3D;&#x3D; null_mark)\n\t\t&#123;\n\t\t\treturn nullptr;\n\t\t&#125;\n\n\n\t\tTreeNode*cur_node &#x3D; new TreeNode(num);\n\t\tcur_node-&gt;left &#x3D; build();\n\t\tcur_node-&gt;right &#x3D; build();\n\t\treturn cur_node;\n\t&#125;\n    \n\tTreeNode* find(TreeNode*cur_node,T target)\n\t&#123;\n\t\tif(cur_node&#x3D;&#x3D;nullptr||cur_node-&gt;val&#x3D;&#x3D;target)return nullptr;\n        if(cur_node-&gt;left-&gt;val&#x3D;&#x3D;target||cur_node-&gt;right-&gt;val&#x3D;&#x3D;target)\n        &#123;\n            return cur_node;\n        &#125;\n        TreeNode*fa&#x3D;find(cur_node-&gt;left,target);\n        if(fa!&#x3D;nullptr)return fa;\n        return find(cur_node-&gt;right,target);\n\t&#125;\n\t\n&#125;;\n\nint main()\n&#123;\n\tint mark &#x3D; 0;\n\tTree&lt;int&gt; t(mark);\n    int ops&#x3D;0;\n    int num&#x3D;0;\n    cin&gt;&gt;ops;\n\tfor(int i&#x3D;0;i&lt;ops;i++)\n    &#123;\n        cin&gt;&gt;num;\n        t.parent&#x3D;t.find(t.root,num);\n        if(!t.parent)\n        &#123;\n            cout&lt;&lt;0&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;t.parent-&gt;val&lt;&lt;endl;\n        &#125;\n        t.parent&#x3D;nullptr;\n    &#125;\n\treturn 0;\n&#125;\n\n字符串KMP#include&lt;string.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n&#123;\npublic:\n\tint*next;\n\tchar pattern[100500];\n    char target[100500];\n    int len1&#x3D;0;\n    int len2&#x3D;0;\n\tvoid init()\n\t&#123;\n\t\tscanf(&quot;%s&quot;,&amp;target);\n        getchar();\n        scanf(&quot;%s&quot;,&amp;pattern);\n        getchar();\n        len1&#x3D;strlen(target);\n        len2&#x3D;strlen(pattern);\n\t\tcout&lt;&lt;Strstr();\n\t&#125;\n\n\tvoid buildnext()\n\t&#123;\n\t\tint len &#x3D; len2;\n\t\tnext &#x3D; new int[len];\n\t\tnext[0] &#x3D; -1;\n\t\tint k &#x3D; -1;\n\t\tfor (int i &#x3D; 0; i &lt; len - 1; i++)\n\t\t&#123;\n\t\t\twhile (k &gt;&#x3D; 0 &amp;&amp; pattern[i] !&#x3D; pattern[k])k &#x3D; next[k];\n\t\t\tnext[i + 1] &#x3D; ++k;\n\t\t&#125;\n\t\tcout &lt;&lt; next[len &#x2F; 4] &lt;&lt; &#39; &#39;;\n\t\tcout &lt;&lt; next[len &#x2F; 2] &lt;&lt; &#39; &#39;;\n\t\tcout &lt;&lt; next[3 * len &#x2F; 4] &lt;&lt; &#39; &#39; &lt;&lt; endl;\n\t&#125;\n\n\tint Strstr()\n\t&#123;\n\t\tbuildnext();\n\t\tint m &#x3D; len1;\n\t\tint n &#x3D; len2;\n\t\tint i &#x3D; 0;\n\t\tint j &#x3D; 0;\n\t\twhile (i &lt; m&amp;&amp;j &lt; n)\n\t\t&#123;\n\t\t\tif (j &#x3D;&#x3D; -1 || target[i] &#x3D;&#x3D; pattern[j])\n\t\t\t&#123;\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tj &#x3D; next[j];\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (j &#x3D;&#x3D; n)return i - j;\n\t\treturn -1;\n\t&#125;\n\n\t~Solution()\n\t&#123;\n\t\tdelete[]next;\n\t&#125;\n&#125;;\n\n图图的存储结构与遍历一些基本概念图G由两个集合V和E组成，记为G &#x3D; (V , E)；其中 V 是 顶点的有穷非空集合，E 是连接 V 中两个不同顶点的边的有 穷集合。通常，也将图G的顶点集和边集分别记为V(G)和E(G)。\n若图中的边限定为从一个顶点指向另一个顶点，则称此图为 有向图。 若图中的边无方向性，则称之为无向图。\n若G &#x3D; (V, E)是有向图，则它的一条有向边是由V中两个 顶点构成的有序对，亦称为弧，记为，其中w是边的始 点，又称弧尾； v是边的终点，又称弧头。\n在一个无向图中，若存在一条边(w, v)，则称w, v为此边 的两个端点，它们是相邻的，并称它们互为邻接顶点。 在一个有向图中，若存在一条边，则称顶点w邻接到顶 点v，顶点v邻接自顶点w。\n由于E是边的集合，故一个图中不会多次出现一条边。 若去掉此限制，则由此产生的结构称为多重图。图 (c)就是一 个多重图。\n设G是无向图，vV(G)，E(G)中以v为端点的边的个 数，称为顶点v的度。\n若G是有向图，则v的出度是以v为始点的边的个数，v 的入度是以v为终点的边的个数 ，顶点的度&#x3D;入度+出 度。\n度数&#x3D;2e\n设G是图，若存在一个顶点序列 使得 或 属于E(G)， 则称vp到vq存在一条路径，其中vp 称为起点，vq称为终点。 路径的长度是该路径上边的个数。  如果一条路径上除了起点和终点可以相同外，再不能有相同 的顶点，则称此路径为简单路径。 如果一条简单路径的起点和终点相同，且路径长度大于等于 2，则称之为简单回路。\n欧拉回路（一笔画） 每条边经过一次\n汉密尔顿回路 每个顶点经过一次\n设G，H是图，如果V(H) 包含于 V(G)，E(H) 包含于 E(G)， 则称H是G的子图，G是H的母图。如果H是G的子图， 并且V(H) &#x3D; V(G)，则称H为G的支撑子图。\n设G是图，若存在一条从顶点vi到顶点vj的路径， 则称vi与vj可及（连通）。 若G为无向图，且V(G)中任意两顶点都可及，则称G 为连通图。 若G为有向图，且对于V(G)中任意两个不同的顶点vi 和vj ， vi与vj可及， vj与vi也可及，则称G为强连通图\n设图G &#x3D; (V，E)是无向图，若G的子图GK是一个连通 图，则称GK为G的连通子图；G的极大连通子图称为 G的连通分量 。 设图G &#x3D; (V，E)是有向图，若G的子图GK是一个强连 通图，则称GK 为G的强连通子图；G的极大强连通子 图称为G的强连通分量 。\n权图，权重\n无向图 有向图 无向边 有向边（弧） 端点 弧头 弧尾 相邻的 邻接到 邻接自 度 出度 入度 连通图 强连通图 连通子图 强连通子图 连通分量 强连通分量\n存储结构邻接矩阵用顺序方式存储图的顶点表v0 ,v1 ,…vn−1，图的边用 n*n 阶矩阵 A&#x3D;(aij) 表示，A 的定义如下: \n⑴若非权图，则: \n➢aii &#x3D; 0； \n➢aij &#x3D; 1，当 i ≠ j 且 vi 与vj之间存在边； \n➢aij &#x3D; 0，当 i 不等于 j 且 vi 与vj之间不存在边。 \n⑵若权图，则: \n➢aii &#x3D; 0； \n➢aij &#x3D; 边的权值，当 i ≠ j 且 vi 与vj之间存在边； \n➢aij &#x3D; 正无穷，当 i ≠ j 且 vi 与vj之间不存在边。\n借助邻接矩阵可方便的求出图中顶点的度 \n无向无权图 矩阵的第i行（或第i列）的1的个数是顶点Vi的度。\n有向无权图 邻接矩阵第i行的1的个数为顶点Vi的出度 第i列的1的个数为顶点Vi的入度。\n邻接表➢ 顺序存储顶点表。 \n➢ 对图的每个顶点建立一个单链表，第 i 个单链表中的结点包 含顶点vi的所有邻接顶点（边链表）。 \n➢ 由顺序存储的顶点表和链接存储的边链表构成的图存储结构 被称为邻接表。\n➢与顶点 v 邻接的所有顶点以某种次序组成的单链表称为顶点 v 的边链表。\n ➢边链表的每一个结点叫做边结点，对于非权图和权图边结点 结构分别为: 其中, 域VerAdj存放 v 的某个邻接顶点在顶点表中的下标；域 link存放指向 v 的边链表中结点 VerAdj 的下一个结点的指针。 域cost 存放边(v, VerAdj)或的权值；\nstruct Vertex&#123; &#x2F;&#x2F;顶点表中结点的结构\n\tint VerName; &#x2F;&#x2F;顶点名称\n\tEdge *adjacent;&#x2F;&#x2F;边链表的头指针\n&#125;;\n\nstruct Edge&#123; &#x2F;&#x2F;边结点的结构\n\tint VerAdj; &#x2F;&#x2F;邻接顶点序号\n\tint cost; &#x2F;&#x2F;边的权值\n\tEdge *link; &#x2F;&#x2F;指向下一个边结点的指针\n&#125;;\n\n有向图：边结点的个数 &#x3D; e， e为图中边的条数\n无向图：边结点的个数&#x3D;2e， e为图中边的条数\n边结点的个数&#x3D;2e e为图中边的条数，但是，如果要统计一个顶点的入度，就要遍历所有的边结点， 其时间复杂度为O(e)（e为图中边的个数）， 从而统计所有顶点入度的时间复杂度为O(ne)（n为图的顶点 个数），对有向图建立逆邻接表（顶点 的指向关系与邻接表恰好相反 ），根据逆邻接表，很容易统 计出图中每个顶点的入度。\n采用邻接矩阵还是用邻接表来存储图，要视对给定图实施的 具体操作。 对边很多的图（也称稠密图），适于用邻接矩阵存储，因占 用的空间少。另一好处是可以将图中很多运算转换成矩阵运 算，方便计算。 对顶点多边少的图（也称稀疏图，如微信有几亿用户，每个 用户好友一般三五百个），若用邻接矩阵存储，对应的邻接 矩阵将是一个稀疏矩阵，存储利用率很低。因此，顶点多而 边少的图适于用邻接表存储。\n#include&lt;iostream&gt;\nusing namespace std;\n\nclass edge\n&#123;\npublic:\n\tint val;\n\tint weight;\n\tedge*link;\n\tedge(int val, int weight)\n\t&#123;\n\t\tthis-&gt;val &#x3D; val;\n\t\tlink &#x3D; nullptr;\n\t\tthis-&gt;weight &#x3D; weight;\n\t&#125;\n&#125;;\n\nclass Vertex\n&#123;\npublic:\n\tint val;\n\tedge*adjacent;\n\tVertex(int val)\n\t&#123;\n\t\tthis-&gt;val &#x3D; val;\n\t\tadjacent &#x3D; nullptr;\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tint node_num &#x3D; 0;\n\tcin &gt;&gt; node_num;\n\tint edge_num &#x3D; 0;\n\tcin &gt;&gt; edge_num;\n\tVertex*store[20100];\n\t&#x2F;&#x2F;初始化\n\tfor (int i &#x3D; 0; i &lt; node_num; i++)\n\t&#123;\n\t\tstore[i] &#x3D; new Vertex(i);\n\t&#125;\n\t&#x2F;&#x2F;输入边\n\tfor (int i &#x3D; 0; i &lt; edge_num; i++)\n\t&#123;\n\t\tint val &#x3D; 0;\n\t\tcin &gt;&gt; val;\n\t\tint next &#x3D; 0;\n\t\tcin &gt;&gt; next;\n\t\tint weight &#x3D; 0;\n\t\tcin &gt;&gt; weight;\n\t\tedge*new_edge &#x3D; new edge(next,weight);\n\t\tif (!store[val]-&gt;adjacent)\n\t\t&#123;\n\t\t\tstore[val]-&gt;adjacent &#x3D; new_edge;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\t\n\t\t\tif (next &lt; store[val]-&gt;adjacent-&gt;val)\n\t\t\t&#123;\n\t\t\t\tedge*temp &#x3D; store[val]-&gt;adjacent;\n\t\t\t\tstore[val]-&gt;adjacent&#x3D;new_edge ;\n\t\t\t\tnew_edge-&gt;link &#x3D; temp;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tedge*ptr &#x3D; store[val]-&gt;adjacent;\n\t\t\t\twhile (ptr-&gt;link&amp;&amp;next &gt;&#x3D; ptr-&gt;link-&gt;val)\n\t\t\t\t&#123;\n\t\t\t\t\tptr &#x3D; ptr-&gt;link;\n\t\t\t\t&#125;\n\t\t\t\tedge*temp &#x3D; ptr-&gt;link;\n\t\t\t\tptr-&gt;link &#x3D; new_edge;\n\t\t\t\tnew_edge-&gt;link &#x3D; temp;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;删除边\n\tint ops &#x3D; 0;\n\tcin &gt;&gt; ops;\n\tfor (int i &#x3D; 0; i &lt; ops; i++)\n\t&#123;\n\t\tint node &#x3D; 0;\n\t\tcin &gt;&gt; node;\n\t\tint next &#x3D; 0;\n\t\tcin &gt;&gt; next;\n\t\tedge*ptr &#x3D; store[node]-&gt;adjacent;\n\t\tif (ptr-&gt;val &#x3D;&#x3D; next)\n\t\t&#123;\n\t\t\tedge*temp &#x3D; ptr-&gt;link;\n\t\t\tstore[node]-&gt;adjacent &#x3D; temp;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\twhile (ptr-&gt;link&amp;&amp;ptr-&gt;link-&gt;val !&#x3D; next)\n\t\t\t&#123;\n\t\t\t\tptr &#x3D; ptr-&gt;link;\n\t\t\t&#125;\n\t\t\tedge*temp &#x3D; ptr-&gt;link-&gt;link;\n\t\t\tptr-&gt;link &#x3D; temp;\n\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;输出边\n\tfor (int i &#x3D; 0; i &lt; edge_num; i++)\n\t&#123;\n\t\tif (!store[i]||!store[i]-&gt;adjacent)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tcout &lt;&lt; store[i]-&gt;val &lt;&lt; &quot;:&quot;;\n\n\t\tedge*e &#x3D; store[i]-&gt;adjacent;\n\t\twhile (e)\n\t\t&#123;\n\t\t\tprintf(&quot;(%d,%d,%d)&quot;, store[i]-&gt;val, e-&gt;val, e-&gt;weight);\n\n\t\t\te &#x3D; e-&gt;link;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n图的遍历图中可能存在回路，且图的任一顶点都可能与其它顶点连通， 在访问完某个顶点之后可能会沿着某些边又回到了曾经访问 过的顶点。 ➢ 为了避免重复访问，可用一个辅助数组vis[ ]记录顶点是否被 访问过，数组各元素初始值为0。在遍历过程中，一旦某一 个顶点 i被访问，就置 vis[i] 为 1。\n深度优先遍历&#x2F;搜索 DFS ( Depth First Search, DFS)递归算法：\nvoid DFS(Vertex*Head, int v, int vis[])&#123; &#x2F;&#x2F;vis初值为0\n\t&#x2F;&#x2F;以v为起点进行深度优先搜索\n\tprintf(“%d ”,v); vis[v]&#x3D;1; &#x2F;&#x2F;访问顶点v\n\tEdge* p&#x3D; Head[v].adjacent; &#x2F;&#x2F;考察v的所有邻接顶点\n\twhile(p!&#x3D;NULL)\n    &#123;\n\t\tif(vis[p-&gt;VerAdj]&#x3D;&#x3D;0) &#x2F;&#x2F;p未被访问\n\t\t\tDFS(Head,p-&gt;VerAdj,vis); &#x2F;&#x2F;以p为起点继续深搜\n\t\tp&#x3D;p-&gt;link;\n\t&#125;\n&#125;\n\nfor(int i&#x3D;0;i&lt;n;i++)\n&#123;\n\tif(vis[i]&#x3D;&#x3D;0)\n\tDFS(Head, i, vis);\n&#125;\n\n非递归算法：\n① 将所有顶点的vis[ ]值置为0, 初始顶点v0入栈；\n② 检测栈是否为空，若栈为空，则算法结束； \n③ 从栈顶弹出一个顶点v，如果v未被访问过则： 访问v，并将vis[v]值更新为1； 将v的未被访问的邻接顶点入栈； \n④ 执行步骤 ② 。\n\n\n广度优先遍历邻接表\nvoid BFS(Vertex* Head, int v, int n, int vis[])\n\tQueue Q; &#x2F;&#x2F;创建队列Q，队列需预先实现\n\tfor(int i&#x3D;0; i&lt;n; i++) vis[i]&#x3D;0;\n\tprintf(“%d ”,v); vis[v]&#x3D;1;&#x2F;&#x2F;访问点v\n\tQ.Enqueue(v); &#x2F;&#x2F;起点v入队\n\twhile(!Q.Empty())\n    &#123;\n\t\tv&#x3D;Q.Dequeue(); &#x2F;&#x2F;出队一个点\n\t\tfor(Edge* p&#x3D;Head[v].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)\n\t\t\tif(vis[p-&gt;VerAdj]&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;考察v的邻接顶点p\n\t\t\t\tprintf(“%d ”, p-&gt;VerAdj);\n\t\t\t\tvis[p-&gt;VerAdj] &#x3D; 1;\n\t\t\t\tQ.Enqueue(p-&gt;VerAdj);\n\t\t\t&#125; &#x2F;&#x2F;end if\n\t&#125; &#x2F;&#x2F;end while\n&#125; &#x2F;&#x2F;end BFS\n\n邻接矩阵\nvoid BFS(int** A, int v, int n, int vis[])&#x2F;&#x2F;邻接矩阵存图\n\tQueue Q; &#x2F;&#x2F;创建队列Q\n\tfor(int i&#x3D;0; i&lt;n; i++) vis[i]&#x3D;0;\n\tprintf(“%d ”,v); vis[v]&#x3D;1;&#x2F;&#x2F;访问点v\n\tQ.Enqueue(v); &#x2F;&#x2F;起点v入队\n\twhile(!Q.Empty())&#123;\n\t\tv&#x3D;Q.Dequeue(); &#x2F;&#x2F;出队一个点\n\t\tfor(int i&#x3D;0; i&lt;n; i++)\n\t\t\tif(A[v][i]&#x3D;&#x3D;1 &amp;&amp; vis[i]&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;考察v的邻接顶点\n\t\t\t\tprintf(“%d ”, i);\n\t\t\t\tvis[i] &#x3D; 1;\n\t\t\t\tQ.Enqueue(i);\n\t\t\t&#125; &#x2F;&#x2F;end if\n\t&#125; &#x2F;&#x2F;end while\n&#125; &#x2F;&#x2F;end BFS\n\n图遍历的应用举例判断无向图是否连通及连通分量数目：\n方案1：DFS \n方案2：并查集\n判断图中顶点u到v是否存在路径：\n以u为起点遍历，看遍历过程中是否经过v\n判断无向图中是否有环：\n1，深度优先遍历，遍历过程中遇到之前访问过的顶点（不能 是当前访问点的前驱），即有环\n2，并查集（连通关系等价于等价关系）\n判断有向图中是否有环：\n在深度优先遍历过程中，一个顶点会经历3种状态：\n➢ vis[i]&#x3D;0，顶点i尚未被遍历到。 \n➢ vis[i]&#x3D;1，顶点i已经被遍历到，但对于它的遍历尚未结束。 该顶点还有若干邻接顶点尚未遍历，当前算法正在递归地深 入探索该顶点的某一邻接顶点。顶点i在当前探索的路径上。 \n➢ vis[i]&#x3D;2，顶点i的所有邻接顶点已完成遍历，其自身的遍历 也已结束。\n有环：DFS过程中遇到已访问过的且vis值为1的点\n拓扑排序关键概念AOV网；\n拓扑序列；\n性质没有有向环\n拓扑序列未必唯一 \n算法从图中选择一个入度为0的顶点并输出。\n从图中删除该顶点及该顶点引出的所有边。\n执行前两步，直至所有顶点已输出，或图中剩余顶点 入度均不为0（说明存在环，无法继续拓扑排序）。\n实现建立一个数组count[ ]，count[i]为顶点i的入度；\n建立一个栈，存放入度为0的顶点，每当一个顶点的 入度为0，就将其压栈。\n\n\n优化关键路径关键概念 AOE网:\n有向边表示活动或任务(Activity) \n边上的权值表示活动的持续时间\n顶点称为事件： 表示其入边的任务已完成，出边的任务可开始的状态。\n 源点：表示整个工程的开始(入度为0)\n汇点：表示整个工程的结束(出度为0)\n关键路径：从源点到汇点的最长路径称。\n关键活动：关键路径上的活动。\n事件 vj的最早发生时间 ve(j) ：从源点 v1 到 vj 的最长路径的长度\n事件 vj的最迟发生时间vl(j) ：等于ve(n)减去 vj 到 vn 的最长路径长度\n活动 ai 的最早开始时间 e(i) :e(i) &#x3D; ve( j),j为起始点\n活动 ai的最迟开始时间l(i)：l(i) &#x3D; vl(k)-weight(&lt;j,k&gt;)，j为起点，k为终点\n求关键路径算法 对AOE网进行拓扑排序，按顶点拓扑序求各顶点vj的最早 发生时间 ve(j)； \n按顶点的逆拓扑序求各顶点 vj的最迟发生时间vl(j)； \n根据各顶点ve和vl值，求出各活动 ai 的最早开始时间 e(i) 和最迟开始时间l(i)，若 e(i)&#x3D; l(i)，则ai是关键活动。\n计算最短时间&#x2F;&#x2F;ve用来存储所有节点的最长路径长度值\nvoid VertexEarliestTime(Vertex Head[],int n, int ve[])&#123;\n&#x2F;&#x2F;计算顶点的最早发生时间\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)ve[i]&#x3D;0;&#x2F;&#x2F;初始化\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++) &#x2F;&#x2F;按拓扑序计算各顶点最早发生时间，i是拓扑排序的顺序的下标\n\t\tfor(Edge* p&#x3D;Head[i].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;&#x2F;&#x2F;链接存储遍历链表内所有节点\n\t\t\tint k&#x3D;p-&gt;VerAdj;&#x2F;&#x2F;k是节点的下标\n\t\t\tif(ve[i]+p-&gt;cost&gt;ve[k])&#x2F;&#x2F;更新更大值\n\t\t\tve[k]&#x3D;ve[i]+p-&gt;cost;\n\t\t&#125;\n&#125;\n\n&#x2F;&#x2F;没有按拓扑排序顺序编号需要预处理排序形成拓扑数组\nvoid VertexEarliestTime(Vertex Head[],int Topo[],int n,int ve[])&#123;\n&#x2F;&#x2F;拓扑序存储在Topo数组中\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)ve[i]&#x3D;0;\n\t\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n\t\t&#x2F;&#x2F;按拓扑序计算各顶点最早发生时间\n\t\t\tEdge* p&#x3D;Head[Topo[i]].adjacent;\n\t\t\twhile(p!&#x3D;NULL)&#123;\n\t\t\t\tint k&#x3D;p-&gt;VerAdj;\n\t\t\t\tif(ve[Topo[i]]+p-&gt;cost&gt;ve[k])\n\t\t\t\tve[k]&#x3D;ve[Topo[i]]+p-&gt;cost;\n\t\t\t\tp&#x3D;p-&gt;link;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n&#x2F;&#x2F;拓扑排序时更新\nvoid TopoOrder(Vertex Head[], int n)&#123;\n\tint count[N]; Stack s;\n\tInDegree(Head, n, count); &#x2F;&#x2F;求每个顶点的入度\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) if(count[i]&#x3D;&#x3D;0) s.PUSH(i);\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n\t\t\tif(s.IsEmpty()) return;\n\t\t\tint j&#x3D;s.POP(); &#x2F;&#x2F;选出1个入度为0的顶点输出\n\t\t\t\tfor(Edge *p&#x3D;Head[j].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;\n\t\t\t\t\t&#x2F;&#x2F;删除j和j引出的边，其效果是j的邻接顶点的入度减1\n\t\t\t\t\tint k&#x3D;p-&gt;VerAdj; count[k]--; \n\t\t\t\t\tif(count[k]&#x3D;&#x3D;0) s.PUSH(k);\n                    &#x2F;&#x2F;多一步更新\n\t\t\t\t\tif(ve[k]+p-&gt;cost&gt;ve[k]) ve[k]&#x3D;ve[k]+p-&gt;cost;\n\t\t\t\t&#125;\n\t\t&#125;\n&#125;\n\n计算最迟发生时间void VertexLatestTime(Vertex* Head,int n,int ve[],int vl[])&#123;\n\t&#x2F;&#x2F;计算顶点的最迟发生时间\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\tvl[i]&#x3D;ve[n];\n\t\tfor(int i&#x3D;n;i&gt;&#x3D;1;i--)&#123; &#x2F;&#x2F;按拓扑逆序计算各顶点最迟发生时间\n\t\t\tfor(Edge* p&#x3D;Head[i].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;\n\t\t\t\tint k&#x3D;p-&gt;VerAdj;\n\t\t\t\tif(vl[k]-p-&gt;cost &lt; vl[i])\n\t\t\t\tvl[i] &#x3D; vl[k]-p-&gt;cost;\n\t&#125;\n&#125;\n    \nvoid VertexLatestTime(Vertex *Head,int n, int Topo[],int ve[],int vl[])&#123;\n&#x2F;&#x2F;计算顶点的最迟发生时间\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)vl[i]&#x3D;ve[n];\n\t\tfor(int i&#x3D;n;i&gt;&#x3D;1;i--)&#123; &#x2F;&#x2F;按拓扑逆序计算各顶点最迟发生时间\n\t\t\tfor(Edge* p&#x3D;Head[Topo[i]].adjacent; p; p&#x3D;p-&gt;link)&#123;\n\t\t\t\tint k&#x3D;p-&gt;VerAdj;\n\t\t\t\tif(vl[k]-p-&gt;cost &lt; vl[Topo[i]])\n\t\t\t\tvl[Topo[i]] &#x3D; vl[k]-p-&gt;cost;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\n求关键活动void ActivityStartTime(Vertex* Head,int n,int ve[],int vl[])&#123;\n&#x2F;&#x2F;求诸活动的最早开始时间和最迟开始时间,并求关键活动\n\tfor(int i &#x3D; 1;i&lt;&#x3D;n;i++)&#123;\n\t\tfor(Edge* p&#x3D;Head[i].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link)&#123;\n\t\t\tint k &#x3D; p-&gt;VerAdj;\n\t\t\tint e &#x3D; ve[i];\n\t\t\tint l &#x3D; vl[k] – p-&gt;cost;\n\t\t\tif(e &#x3D;&#x3D; l) printf(“%d-&gt;%d\\n”,i,k); &#x2F;&#x2F;输出关键活动\n\t\t&#125;\n\t&#125;\n&#125;\n\n主函数const int N&#x3D;1010;\nvoid CriticalPath(Vertex* Head, int n)&#123;\n\t&#x2F;&#x2F;假定图中顶点已按拓扑序编号\n\tint ve[N],vl[N];\nVertexEarliestTime(Head,n,ve); &#x2F;&#x2F;顶点最早发生时间\nVertexLatestTime(Head,n,ve,vl); &#x2F;&#x2F;顶点最迟发生时间\nActivityStartTime(Head,n,ve,vl);&#x2F;&#x2F;活动最早最晚开始时间\n&#125;\n\n\n\n\n最短路径无权图：广度优先遍历Dijkstralc：\nclass Solution &#123;\npublic:\n    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt; &amp;times, int n, int k) &#123;\n        const int inf &#x3D; INT_MAX &#x2F; 2;\n\n        &#x2F;&#x2F; 邻接矩阵存储边信息\n        vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, inf));\n        for (auto &amp;t : times) &#123;\n            &#x2F;&#x2F; 边序号从 0 开始\n            int x &#x3D; t[0] - 1, y &#x3D; t[1] - 1;\n            g[x][y] &#x3D; t[2];\n        &#125;\n\n        &#x2F;&#x2F; 从源点到某点的距离数组\n        vector&lt;int&gt; dist(n, inf);\n        &#x2F;&#x2F; 由于从 k 开始，所以该点距离设为 0，也即源点\n        dist[k - 1] &#x3D; 0;\n\n        &#x2F;&#x2F; 节点是否被更新数组\n        vector&lt;bool&gt; used(n);\n\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点\n            int x &#x3D; -1;\n            for (int y &#x3D; 0; y &lt; n; ++y) &#123;\n                if (!used[y] &amp;&amp; (x &#x3D;&#x3D; -1 || dist[y] &lt; dist[x])) &#123;\n                    x &#x3D; y;\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 用该点更新所有其他点的距离\n            used[x] &#x3D; true;\n            for (int y &#x3D; 0; y &lt; n; ++y) &#123;\n                dist[y] &#x3D; min(dist[y], dist[x] + g[x][y]);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 找到距离最远的点\n        int ans &#x3D; *max_element(dist.begin(), dist.end());\n        return ans &#x3D;&#x3D; inf ? -1 : ans;\n    &#125;\n&#125;;\n\n\n优先队列优化：\nclass node\n&#123;\npublic:\n\tint to;\n\tint weight;\n\tnode()\n\t&#123;&#125;\n\tnode(int t, int w)\n\t&#123;\n\t\tto &#x3D; t;\n\t\tweight &#x3D; w;\n\t&#125;\n\tbool operator&lt;(const node&amp;b) const\n\t&#123;\n\t\treturn  weight &gt; b.weight;\n\t&#125;\n&#125;;\n\nvoid dijkstra()\n&#123;\n\tdist[s] &#x3D; 0;\n\n\tnow.to &#x3D; s;\n\tnow.weight &#x3D; 0;\n\n\tcnt[0] &#x3D; 0;\n\n\tpriority_queue&lt;node&gt;q;\n\tq.push(now);\n\n\twhile (!q.empty())\n\t&#123;\n\t\tnow &#x3D; q.top();\n\t\tq.pop();\n\t\tif (used[now.to] &#x3D;&#x3D; true)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tused[now.to] &#x3D; true;\n\t\tint len &#x3D; map[now.to].size();\n\t\tfor (int i &#x3D; 0; i &lt; len; i++)\n\t\t&#123;\n\t\t\ttmp &#x3D; map[now.to][i];\n\t\t\tif (dist[tmp.to] &gt; dist[now.to] + tmp.weight)\n\t\t\t&#123;\n\t\t\t\tdist[tmp.to] &#x3D; dist[now.to] + tmp.weight;\n\t\t\t\tq.push(node(tmp.to, dist[tmp.to]));\n\t\t\t\tpath[tmp.to] &#x3D; now.to;\n\t\t\t\tcnt[tmp.to] &#x3D; cnt[now.to] + 1;\n\t\t\t&#125;\n\t\t\telse if (dist[tmp.to] &#x3D;&#x3D; dist[now.to] + tmp.weight&amp;&amp;cnt[tmp.to] &gt; cnt[now.to] + 1)\n\t\t\t&#123;\n\t\t\t\tpath[tmp.to] &#x3D; now.to;\n\t\t\t\tcnt[tmp.to] &#x3D; cnt[now.to] + 1;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n课内：\n引入3个辅助数组 dist[]、path[]、S[]. \n✓ dist[i] ： 从 源 点 s 到 顶 点 i 的 最 短 距 离 ， 初 始 时 dist[s]&#x3D;0, dist[i]&#x3D;+∞（任意 i ≠ s）. \n✓ path[i]：s到i最短路径上i的前驱顶点编号，初始时path[i]&#x3D; -1 . \n✓ S[i]：顶点i最是否在集合S中，初始时S[i]&#x3D; 0.\nconst int INF&#x3D;0X3f3f3f3f, N&#x3D;1e5+10;\nvoid Dijkstra(Vertex *Head,int n,int s,int dist[],int path[])&#123;\n\tint S[N], i, j, min, v, w;\n    \n\tfor(i&#x3D;1; i&lt;&#x3D;n; i++) &#123;path[i]&#x3D;-1; dist[i]&#x3D;INF; S[i]&#x3D;0;&#125;&#x2F;&#x2F;初始化\n\tdist[s]&#x3D;0;\n    \n\tfor(i&#x3D;1; i&lt;&#x3D;n; i++) &#123;\n\t\tmin&#x3D;INF; &#x2F;&#x2F;从不在S集合中的顶点中选D值最小的顶点v\n\t\tfor(j&#x3D;1;j&lt;&#x3D;n;j++) if(S[j]&#x3D;&#x3D;0 &amp;&amp; dist[j]&lt;min)&#123;min&#x3D;dist[j];v&#x3D;j;&#125;\n        \n\t\tS[v]&#x3D;1; &#x2F;&#x2F;将顶点v放入S集合\n        \n\t\tfor(Edge* p&#x3D;Head[v].adjacent; p!&#x3D;NULL; p&#x3D;p-&gt;link) &#123;\n\t\t\tw&#x3D;p-&gt;VerAdj; &#x2F;&#x2F;更新v的邻接顶点的D值\n\t\t\tif(S[w]&#x3D;&#x3D;0 &amp;&amp; dist[v]+p-&gt;cost&lt;dist[w]) &#123;\n\t\t\t\tdist[w]&#x3D;dist[v]+p-&gt;cost; \n                path[w]&#x3D;v;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid PrintPath(int path[], int s, int t)&#123;\n\t&#x2F;&#x2F;输出s到t的最短路\n\tif(s&#x3D;&#x3D;t) &#123;printf(“%d ”,s); return;&#125;\n\t\tPrintPath(s,path[t]);&#x2F;&#x2F;输出s到t前驱的最短路\n\t\tprintf(“%d ”,t); &#x2F;&#x2F;输出t\n&#125;\n\n\n初始时（ s为源点），令Ds &#x3D;0且 Di &#x3D; ∞ （任意 i≠ s）； \n①从不在集合S中的顶点选择Dv最小的顶点v，将其放入集合S； \n②考察v的不在S中的邻接顶点w，若Dv+weight(v,w) &lt; Dw，则更新Dw， 使Dw&#x3D;Dv+weight(v,w) . \n③重复① ② ，直至所有顶点都放入集合S。\nDijkstra算法总结不能处理负权图。选出D值最小的顶点v， 加入集合S后，源点到v的最短距离即确定。但在负权图中， v加入集合S后，源点到v的最短距离也不确定。\nBellman-Ford第k次迭代，一定找到V1到各点的至多包含k条边的最短距离\n最短路径最多包含全部n个顶点，n-1条 边，即V1到各点的最短路径至多包含n-1条边，故至多迭代 n-1次。\n如果n-1次迭代后，再做1次迭代，最短路径还有变化，则肯 定含有负环。\nbool Bellman_Ford(Edge ed[], int s, int n, int e, int D[])&#123;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++) D[i]&#x3D;INF; &#x2F;&#x2F;初始化\n\tD[s]&#x3D;0;\n\tfor(int i&#x3D;1; i&lt;&#x3D;n-1; i++) &#x2F;&#x2F;n-1轮松弛操作\n    &#123;\n        &#x2F;&#x2F;不需要去寻找起点，其他点是正无穷，加上权值后仍是正无穷，不会更新\n        &#x2F;&#x2F;已经加过的边再加会大于原来的距离，不会更新\n\t\tfor(int k&#x3D;0; k&lt;e; k++) \n        &#123; &#x2F;&#x2F;扫描所有边\n\t\t\tint u&#x3D;ed[k].u; int v&#x3D;ed[k].v; int w&#x3D;ed[k].weight;\n\t\t\tif(D[u]+w&lt;D[v]) D[v]&#x3D;D[u]+w;\n\t\t&#125;\n    &#125;\n\t\n    for(int k&#x3D;0; k&lt;e; k++) \n    &#123; &#x2F;&#x2F;检测负环\n\t\tint u&#x3D;ed[k].u; int v&#x3D;ed[k].v; int w&#x3D;ed[k].weight;\n\t\tif(D[u]+w&lt;D[v]) return false; &#x2F;&#x2F;有负环\n\t&#125;\n\treturn true;\n&#125;\n\nSPFA算法采用一个队列。 初始时将源点入队，每次从队列中取 出一个顶点，并考察其邻接顶点，若某个顶点D值被更新， 则将其入队。 直至队列为空时算法结束。\n最坏情况下时间复杂度与Bellman-Ford算法相同，为O(ne)。 但在稀疏图上运行效率较高，为O(ke)，其中k为一个较小的 常数。\nbool SPFA(Vertex* Head, int n, int s, int D[]) &#123;\n\tQueue Q; \n    int InQueue[N]&#x3D;&#123;0&#125;, times[N]&#x3D;&#123;0&#125;, D[N];\n\tmemset(D, 0x3f, sizeof(D));\n\tD[s] &#x3D; 0; Q.ENQUEUE(s); InQueue[s] &#x3D; 1; times[s]++;\n\twhile(!Q.Empty()) \n    &#123;\n\t\tint u &#x3D; Q.DEQUEUE(); InQueue[u] &#x3D; 0;\n\t\tfor (Edge* p &#x3D; Head[u].adjacent; p !&#x3D; NULL; p &#x3D; p-&gt;link) \n        &#123;\n\t\t\tint v &#x3D; p-&gt;VerAdj;\n\t\t\tif(D[u] + p-&gt;cost &lt; D[v]) &#123;\n\t\t\t\tD[v] &#x3D; D[u] + p-&gt;cost;\n\t\t\t\tif(!InQueue[v]) \n                &#123;\n\t\t\t\t\tQ.ENQUEUE(v); InQueue[v] &#x3D; 1; times[v]++; &#x2F;&#x2F;入队次数+1\n\t\t\t\t\tif(times[v] &gt;&#x3D; n) return false; &#x2F;&#x2F;入队次数&gt;&#x3D;n则存在负环\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn true;\n&#125;\n\n\n✓顶点可以多次进出队 \n✓ 顶点每次入队D值更新1次 \n✓ 若入队次数大于等于n次，则存在负环\nFLOYD用邻接矩阵存图在A中，D中存储最短路径长度，path中存储路径当前节点的下一个节点\nvoid Floyd(int **A, int n, int **D, int **path)\n&#123; \n\tfor(int i&#x3D;1; i&lt;&#x3D;n; i++) &#x2F;&#x2F;初始化\n\t\tfor(int j&#x3D;1; j&lt;&#x3D;n; j++) \n\t\t&#123;\n\t\t\tD[i][j]&#x3D;A[i][j];\n\t\t\tif(i!&#x3D;j &amp;&amp; A[i][j]&lt;INF) path[i][j]&#x3D;j;\n\t\t\telse path[i][j]&#x3D;-1;\n\t\t&#125;\n\tfor(int k&#x3D;1; k&lt;&#x3D;n; k++) &#x2F;&#x2F;递推构造D\n\t&#123;\n\t\tfor(int i&#x3D;1; i&lt;&#x3D;n; i++)\n\t\t&#123;\n\t\t\tfor(int j&#x3D;1; j&lt;&#x3D;n; j++)\n\t\t\t&#123;\n\t\t\t\tif(D[i][k]+D[k][j]&lt;D[i][j])\n\t\t\t\t&#123;\n\t\t\t\t\tD[i][j]&#x3D;D[i][k]+D[k][j];\n\t\t\t\t\tpath[i][j]&#x3D;path[i][k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid PrintPath(int s, int t) &#123;\n\tprintf(&quot;%d &quot;, s); \n\tint k &#x3D; s;\n\twhile (k !&#x3D; t) &#123;\n\t\tprintf(&quot;%d &quot;, path[k][t]);\n\t\tk &#x3D; path[k][t];\n\t&#125;\n&#125;\n\nFloyd算法的时间复杂度为O(n 3 )，与调用n次Dijkstra算法求 每对顶点的最短路的时间基本相当，但Floyd算法形式简单、 算法紧凑、便于实现，允许负权边。\n适用于有向图，也适用于无向图。\n不允许存在负环（环上所有边的权值和为负数，理论上不存 在最短路）。Floyd算法可以判负环，初始时D[i][i]&#x3D;0，算法 执行过程中若D[i][i]&lt;0，表示顶点i到自己的最短距离为负值， 即存在负环。（注意是D[i][i]!)\n传递闭包问题Warshall算法不关注路径长度，而是仅关注是否存在路径。 \nvi和vj是有向图G的两个顶点 , 若从 vi到 vj存在一条路径，则称 vi 到 vj可及；\n 传递性: 若 vi到 vj ，vj到 vk皆可及，则 vi 到vk可及. \n描述有向图顶点间可及关系的n阶方阵R称为可及矩阵，若顶 点vi到vj可及，则Rij &#x3D;1，否则Rij &#x3D;0. \n传递闭包: 由有向图 G 的顶点集 V、边集 E，以及新添加的虚 边（表示两顶点可及）构成的图被称为 G 的传递闭包。\nR(k-1) [i][j]表示顶点 i经由{v1 , … ,vk-1 }中顶点到达 j 的可及性. \nR(k) [i][j]表示顶点 i经由{v1 ,… ,vk-1 ,vk }中顶点到达j的可及性. \nR(k) [i][ j] &#x3D; R( k−1)[i][j] OR (R(k−1) [i][k] AND R(k−1)[k][j])\n&#x2F;&#x2F;简单优化后\nvoid Warshall(int A[N][N], int n, int R[N][N]) &#123; \n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) \n\t\t\tif (i&#x3D;&#x3D;j || A[i][j]&lt;INF) R[i][j] &#x3D; 1; \n\t\t\t&#x2F;&#x2F;i和j之间存在边，注意对对无权图是A[i][j]&#x3D;&#x3D;1\n\t\t\telse R[i][j] &#x3D; 0;\n\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#x2F;&#x2F;递推构造Rn\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif(R[i][k])\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif(R[k][j])\n\t\t\t\t\tR[i][j] &#x3D; 1;\n&#125; \n\n变式对于负权图最短路径问题，若图中最小边权是-x（x&gt;0），做一个变换，将所有边的权值加上 x+1，使所有边权值变为正数，再调用Dijkstra求最短路径，该最短 路就是原图的最短路。\n求图的最长路径 :\n对Dijkstra算法稍加修改，将算法中D[v]+weight(v,w)&lt;D[w] 改为D[v]+weight(v,w)&gt;D[w] 。\n若权值都为正，则对所权值取倒数，用Dijkstra算法求最短路径，该 路径就是原图的最长路径。\n若图中不存在正环，对所有边的权值取相反数，执行Floyd或 Bellman-Ford算法求最短路径，该路径就是原图的最长路。\n满足约束的最短路径K 站中转内最短路径使用课内方法是没有次序的随意更新，二维数组可以记录来自不同路径的最短路，避免前一半路径与后一半路径使用的是不同路径\n基于Bellman—Ford：\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;图论中带边数限制的最短路 Bellman—Ford算法\n    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;\n        vector&lt;vector&lt;int&gt;&gt; dp(k+2,vector&lt;int&gt;(n,INT_MAX&#x2F;2));&#x2F;&#x2F;dp[t][j]表示遍历t条边到达目的地j的最短路径\n        dp[0][src]&#x3D;0;\n        int res&#x3D;INT_MAX&#x2F;2;\n        for(int t&#x3D;1;t&lt;&#x3D;k+1;t++)&#123;\n            for(auto&amp; flight:flights)&#123;\n                int i&#x3D;flight[0];\n                int j&#x3D;flight[1];\n                int dis&#x3D;flight[2];\n                dp[t][j]&#x3D;min(dp[t][j],dp[t-1][i]+dis);\n                if(j&#x3D;&#x3D;dst)res&#x3D;min(res,dp[t][j]);\n            &#125;\n        &#125;\n        return res&#x3D;&#x3D;INT_MAX&#x2F;2?-1:res;\n    &#125;\n&#125;;\n\n\n基于狄克斯特拉：\nstruct Edge&#123;\n    int id;\n    int trans;\n    int efforts;\n    Edge(int _id,int _trans,int _efforts):id(_id),trans(_trans),efforts(_efforts)&#123;&#125;\n    bool operator&lt;(const Edge&amp; edge)const&#123;\n        return efforts&gt;edge.efforts;\n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;有向图求最短路\n    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;\n        vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; graph(n);\n        for(int i&#x3D;0;i&lt;flights.size();i++)&#123;\n            int cur&#x3D;flights[i][0];\n            int next&#x3D;flights[i][1];\n            int dis&#x3D;flights[i][2];\n            graph[cur].push_back(&#123;next,dis&#125;);\n        &#125;\n        vector&lt;int&gt; dis(n,INT_MAX);\n        vector&lt;int&gt; transtimes(n,INT_MAX);\n        priority_queue&lt;Edge&gt; pq;\n        pq.push(&#123;src,0,0&#125;);\n        dis[src]&#x3D;0;\n        transtimes[src]&#x3D;0;\n        while(!pq.empty())&#123;\n           Edge edge&#x3D;pq.top();\n           pq.pop();\n           if(edge.trans&gt;k)continue;\n           if(edge.id&#x3D;&#x3D;dst)return edge.efforts;\n           for(auto&amp; flight:graph[edge.id])&#123;\n               int nextid&#x3D;flight.first;\n               int nextefforts&#x3D;edge.efforts+flight.second;\n               int nexttrans&#x3D;edge.trans;\n               if(nextid!&#x3D;dst)nexttrans+&#x3D;1;\n               if(dis[nextid]&gt;nextefforts)&#123;\n                   dis[nextid]&#x3D;nextefforts;\n                   transtimes[nextid]&#x3D;nexttrans;\n               &#125;\n               if(dis[nextid]&lt;nextefforts &amp;&amp; nexttrans&gt;transtimes[nextid])continue;\n               pq.push(&#123;nextid,nexttrans,nextefforts&#125;); \n           &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n\n\n最小支撑树无向带权连通图G，其顶点个数为n，由G中n个顶点和n-1条边 构成的连通子图，称为G的一棵支撑树，亦称生成树。边权之 和最小的支撑树称为G的最小支撑树。(Minimum Spanning Tree, MST )。\n性质：无回路\nkruskal\n\nprim\n\n\n\n堆\n定义 : 堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 故通常我们用完全二叉树来维护一个一维数组\n分类 : 按照堆的特点可以把堆分为大顶堆和小顶堆———-大顶堆：每个结点的值都大于或等于其左右孩子结点的值———-小顶堆：每个结点的值都小于或等于其左右孩子结点的值\n\n  3.完全二叉树维护的一维数组的特点\n对于完全二叉树来说，⌊N&#x2F;2⌋得到的是最后一个非叶子节点的序号\n在完全二叉树中我们发现关系就是 如果父节点的序号为 x, 那么其左孩子节点若存在其序号为 2 * x, 右孩子存在则其序号为 2 * x + 1; 那么一个节点的父节点则为 x &#x2F; 2; 故根据这个序号特点，我们将序号作为数组的下标，将一颗完全二叉树用一个一维数组存储。\n建立大根堆\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvoid heapadjust(vector&lt;int&gt;&amp;store, int k,int len)\n&#123;\n\tstore[0] &#x3D; store[len];\n\tfor (int i &#x3D; 2 * k; i &lt;&#x3D; len; i*&#x3D;2)\n\t&#123;\n\t\tif (i &lt; len&amp;&amp;store[i] &lt; store[i + 1])\n\t\t\ti++;\n\t\tif (store[0] &gt; store[i])\n\t\t\tbreak;\n\t\telse\n\t\t&#123;\n\t\t\tstore[k] &#x3D; store[i];\n\t\t\tk &#x3D; i;\n\t\t&#125;\n\t&#125;\n\tstore[k] &#x3D; store[0];\n&#125;\n\nvoid buildMaxHeap(vector&lt;int&gt;&amp;store,int len)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len &#x2F; 2; i &gt; 0; i--)\n\t&#123;\n\t\theapadjust(store, i);\n\t&#125;\n&#125;\n\n堆排序\nvoid heapSort(vector&lt;int&gt;&amp;store)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len; i &gt;1; i--)\n\t&#123;\n\t\tswap(store[i], store[1]);\n\t\theapadjust(store, 1,i-1);\n\t&#125;\n&#125;\n\n容器priority_queue优先队列是一种会按照默认或自定义的优先级进行自动排序的队列，其特点是优先级高的元素排在队首，低的排在队尾。\n创建    数据类型：可以是int、double等基本类型，也可以是自定义的结构体。    容器类型：一般为deque（双端列表）、vector（向量容器），可省略，省略时以vector为默认容器。\n查找二分查找标准模板int binarysearch(vector&lt;int&gt;nums, int target)\n&#123;\n\tint left &#x3D; 0;\n\tint right &#x3D; nums.size()-1;\n\n\twhile (left &lt;&#x3D; right)\n\t&#123;\n\t\tint mid &#x3D; left + (right - left) &#x2F; 2;\n\t\tif (nums[mid] &#x3D;&#x3D; target)\n\t\t&#123;\n\t\t\treturn mid;\n\t\t&#125;\n\t\telse if (nums[mid] &lt; target)\n\t\t&#123;\n\t\t\tleft &#x3D; mid + 1;\n\t\t&#125;\n\t\telse if (nums[mid] &gt; target)\n\t\t&#123;\n\t\t\tright &#x3D; mid - 1;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n\n&#125;\n              \n\n为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt; ？因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。\n这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。\n我们这个算法中使用的是 [left, right] 两端都闭的区间。这个区间就是每次进行搜索的区间，我们不妨称为「搜索区间」\nwhile(left &lt;&#x3D; right)的终止条件是 left &#x3D;&#x3D; right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候搜索区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。\nwhile(left &lt; right)的终止条件是 left &#x3D;&#x3D; right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就可能出现错误。\n2. 为什么 left &#x3D; mid + 1，right &#x3D; mid - 1？我看有的代码是 right &#x3D; mid 或者 left &#x3D; mid，没有这些加加减减，到底怎么回事，怎么判断？刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？\n当然是去搜索 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。\n红蓝通用模板int find(vector&lt;int&gt;&amp;nums,int bound,int target)\n    &#123;\n        int len&#x3D;nums.size();\n        int left&#x3D;-1;\n        int right&#x3D;bound;\n        while(left+1!&#x3D;right)\n        &#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            if(nums[mid]&lt;target)\n            &#123;\n                left&#x3D;mid;\n            &#125;\n            else\n            &#123;\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        return left;\n    &#125;\nCEFDBHGA\nCBEDFAGH\n\n二叉查找树性质在二叉搜索树中：\n 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值。\n 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值。\n 任意节点的左、右子树也分别为二叉查找树。\n 没有键值相等的节点（no duplicate nodes）。\n对一颗二叉树进行中序遍历，可以按从小到大的顺序，将各结点关键码排列起来，所以也称二叉搜索树为二叉排序树\n代码实现插入：\n在寻找插入位置的过程中确定元素是否已经存在\n删除：\n分四种情况：\n如果想要删除叶结点，只需将其父结点指向它的指针清零，再释放它即可。\n如果被删结点右子树为空，可以拿它的左子女结点顶替它的位置，再释放它。\n如果被删结点左子树为空，可以拿它的右子女结点顶替它的位置，再释放它。\n如果被删结点左、右子树都不空。\n\n&#x2F;&#x2F;二叉搜索树结点类型\ntemplate&lt;typename T&gt;\nstruct BSTNode\n&#123;\n\tT data;    &#x2F;&#x2F;数据域\n\tBSTNode&lt;T&gt; *left, *right;    &#x2F;&#x2F;左子女、右子女\n\tBSTNode() :left(NULL), right(NULL) &#123;&#125;    &#x2F;&#x2F;构造函数\n\t&#x2F;&#x2F;构造函数\n\tBSTNode(const T d, BSTNode&lt;T&gt;* L &#x3D; NULL, BSTNode&lt;T&gt;* R &#x3D; NULL) :data(d), left(L), right(R) &#123;&#125;\n&#125;;\n\n&#x2F;&#x2F;二叉搜索树的定义\ntemplate &lt;class T&gt;\nclass BST\n&#123;\npublic:\n\t&#x2F;&#x2F;普通构造函数\n\tBST() :root(NULL) &#123;&#125;\n\t&#x2F;&#x2F;构造BST\n\tBST(T value) :root(NULL), RefValue(value)\n\t&#123;\n\t\tT x;\n\t\tcin &gt;&gt; x;\n\t\twhile (x !&#x3D; RefValue)\n\t\t&#123;\n\t\t\tInsert(x, root);    &#x2F;&#x2F;新建一个结点，调用Insert插入到树中\n\t\t\tcin &gt;&gt; x;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;析构\n\t~BST() &#123; Destroy(root); &#125;\n\t&#x2F;&#x2F;插入\n\tbool Insert(T x) &#123; return Insert(x, root); &#125;\n\t&#x2F;&#x2F;删除\n\tbool Remove(T x) &#123; return Remove(x, root); &#125;\n\t&#x2F;&#x2F;搜索\n\tbool Search(T x) &#123; return (Search(x, root) !&#x3D; NULL) ? true : false; &#125;\n\t&#x2F;&#x2F;中序遍历\n\tvoid InOrder() &#123; InOrder(root); &#125;\n\nprotected:\n\n\t&#x2F;&#x2F;以ptr为根的二叉搜索树中插入所含值为e1的结点\n\tbool Insert(const T&amp; e1, BSTNode&lt;T&gt;* &amp;ptr)    &#x2F;&#x2F;第二个参数是指针的引用\n\t&#123;\n\t\tif (ptr &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\tptr &#x3D; new BSTNode&lt;T&gt;(e1);    &#x2F;&#x2F;构造新结点\n\t\t\tif (ptr &#x3D;&#x3D; NULL)\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; endl;\n\t\t\t\texit(1);\n\t\t\t&#125;\n\t\t\treturn true;\n\t\t&#125;\n\t\telse if (e1 &lt; ptr-&gt;data)    &#x2F;&#x2F;小于，插入左子树\n\t\t&#123;\n\t\t\tInsert(e1, ptr-&gt;left);\n\t\t&#125;\n\t\telse if (e1 &gt; ptr-&gt;data)    &#x2F;&#x2F;大于，插入右子树\n\t\t&#123;\n\t\t\tInsert(e1, ptr-&gt;right);\n\t\t&#125;\n\t\telse    &#x2F;&#x2F;x已在树中，不插入\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;以ptr为根的二叉搜索树中删除含x的结点\n\tbool Remove(T x, BSTNode&lt;T&gt;* &amp;ptr)\n\t&#123;\n\t\tBSTNode&lt;T&gt;* temp;\n\t\tif (ptr !&#x3D; NULL) &#x2F;&#x2F;ptr不为空进行操作\n\t\t&#123;\n\t\t\tif (x &lt; ptr-&gt;data)\n\t\t\t&#123;\n\t\t\t\tRemove(x, ptr-&gt;left);\n\t\t\t&#125;\n\t\t\telse if (x &gt; ptr-&gt;data)\n\t\t\t&#123;\n\t\t\t\tRemove(x, ptr-&gt;right);\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F;找到了要删除的结点\n\t\t\t&#x2F;&#x2F;1.要删除的结点ptr同时有左右子树\n\t\t\telse if (ptr-&gt;left !&#x3D; NULL &amp;&amp; ptr-&gt;right !&#x3D; NULL)\n\t\t\t&#123;\n\t\t\t\ttemp &#x3D; ptr-&gt;right;    &#x2F;&#x2F;在右子树中搜索中序下的第一个结点\n\t\t\t\twhile (temp-&gt;left !&#x3D; NULL)\n\t\t\t\t&#123;\n\t\t\t\t\ttemp &#x3D; temp-&gt;left;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;用右子树中序下的第一个结点的值填充要删除的结点\n\t\t\t\tptr-&gt;data &#x3D; temp-&gt;data;\n\t\t\t\t&#x2F;&#x2F;然后再新填充值ptr的右子树中删除temp的data值\n\t\t\t\tRemove(ptr-&gt;data, ptr-&gt;right);\n\t\t\t&#125;\n\t\t\telse &#x2F;&#x2F;不同时有左右子树\n\t\t\t&#123;\n\t\t\t\ttemp &#x3D; ptr;        &#x2F;&#x2F;temp记住要删除的ptr结点\n\t\t\t\tif (ptr-&gt;left &#x3D;&#x3D; NULL) &#x2F;&#x2F;只有右子树\n\t\t\t\t&#123;\n\t\t\t\t\tptr &#x3D; ptr-&gt;right;\n\t\t\t\t&#125;\n\t\t\t\telse    &#x2F;&#x2F;只有左子树\n\t\t\t\t&#123;\n\t\t\t\t\tptr &#x3D; ptr-&gt;left;\n\t\t\t\t&#125;\n\t\t\t\tdelete temp;    &#x2F;&#x2F;删除结点\n\t\t\t\ttemp &#x3D; NULL;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse &#x2F;&#x2F;ptr为空直接返回false\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;在ptr为根的二叉搜索树中搜索含x的结点。若找到，返回该结点地址，否则返回NULL\n\tBSTNode&lt;T&gt;* Search(T x, BSTNode&lt;T&gt;* ptr)\n\t&#123;\n\t\tif (ptr &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\treturn NULL;\n\t\t&#125;\n\t\telse if (x &lt; ptr-&gt;data)\n\t\t&#123;\n\t\t\treturn Search(x, ptr-&gt;left);\n\t\t&#125;\n\t\telse if (x &gt; ptr-&gt;data)\n\t\t&#123;\n\t\t\treturn Search(x, ptr-&gt;right);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn ptr;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;中序遍历\n\tvoid InOrder(BSTNode&lt;T&gt;* root)\n\t&#123;\n\t\tif (root !&#x3D; NULL)\n\t\t&#123;\n\t\t\tInOrder(root-&gt;left);\n\t\t\tcout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;\n\t\t\tInOrder(root-&gt;right);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;销毁以root为根的二叉树搜索树函数\n\tvoid Destroy(BSTNode&lt;T&gt;* &amp;root)\n\t&#123;\n\t\tif (root &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (root-&gt;left !&#x3D; NULL)\n\t\t&#123;\n\t\t\tDestroy(root-&gt;left);\n\t\t&#125;\n\t\tif (root-&gt;right !&#x3D; NULL)\n\t\t&#123;\n\t\t\tDestroy(root-&gt;right);\n\t\t&#125;\n\t\tdelete root;\n\t\troot &#x3D; NULL;\n\t&#125;\nprivate:\n\tBSTNode&lt;T&gt;* root;    &#x2F;&#x2F;根指针\n\tT RefValue;    &#x2F;&#x2F;输入结束标识\n&#125;;\n\n\n\nAVL树概念\n它的左右子树都是AVL树\n\n左右子树高度之差(简称平衡因子)的绝对值不超过1(-1&#x2F;0&#x2F;1)\n\n平衡因子的计算是右子树的高度减去左子树的高度的差值结果\n\n四种旋转\nb站视频很清晰\n\n\n代码实现#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nclass AVLnode &#123;\npublic:\n\tAVLnode(const T&amp; el) &#123;\n\t\tinfo &#x3D; el;\n\t\tleft &#x3D; nullptr;\n\t\tright &#x3D; nullptr;\n\t\theight &#x3D; 1;\n\t&#125;\n\tAVLnode&lt;T&gt; *left, *right;\n\tT info;      &#x2F;&#x2F;节点储存值\n\tint height;\n&#125;;\n\ntemplate&lt;class T&gt;\nclass AVLTree &#123;\npublic:\n\tAVLTree() &#123;\n\t\troot &#x3D; nullptr;\n\t&#125;\n\t&#x2F;&#x2F;定义左旋操作\n\tAVLnode&lt;T&gt;* L_rotate(AVLnode&lt;T&gt; *p);\n\t&#x2F;&#x2F;定义右旋操作\n\tAVLnode&lt;T&gt;* R_rotate(AVLnode&lt;T&gt; *p);\n\t&#x2F;&#x2F;左子树右旋，再左旋\n\tAVLnode&lt;T&gt;* LR_rotate(AVLnode&lt;T&gt; *p);\n\t&#x2F;&#x2F;右子树左旋，再右旋\n\tAVLnode&lt;T&gt;* RL_rotate(AVLnode&lt;T&gt; *p);\n\n\tvoid insert(const T&amp; el);\n\tAVLnode&lt;T&gt;* insert_(AVLnode&lt;T&gt;* &amp;p, const T&amp; el);\n\n\tAVLnode&lt;T&gt;* search(const T&amp; el) const;\n\tvoid remove(const T&amp; el);\n\tAVLnode&lt;T&gt;* remove_(AVLnode&lt;T&gt;* &amp;p, AVLnode&lt;T&gt;* cur);\n\tAVLnode&lt;T&gt;* maxleft(AVLnode&lt;T&gt;* p);\n\tAVLnode&lt;T&gt;* minright(AVLnode&lt;T&gt;* p);\n\t&#x2F;&#x2F;获取某个节点的高度\n\tint GetHeight(AVLnode&lt;T&gt; *p) const &#123;\n\t\tif (p &#x3D;&#x3D; nullptr) return 0;\n\t\treturn p-&gt;height;\n\t&#125;\n\n\tAVLnode&lt;T&gt;* root;\n\n&#125;;\n\n&#x2F;&#x2F;以p节点为根左旋\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::L_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;left;\n\tp-&gt;left &#x3D; l-&gt;right;\n\tl-&gt;right &#x3D; p;\n\t&#x2F;&#x2F;更新高度\n\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\tl-&gt;height &#x3D; max(GetHeight(l-&gt;left), GetHeight(l-&gt;right)) + 1;\n\t&#x2F;&#x2F;返回新的根节点l\n\treturn l;\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::R_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;right;\n\tp-&gt;right &#x3D; l-&gt;left;\n\tl-&gt;left &#x3D; p;\n\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\tl-&gt;height &#x3D; max(GetHeight(l-&gt;left), GetHeight(l-&gt;right)) + 1;\n\treturn l;\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::LR_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;left;\n\tp-&gt;left &#x3D; R_rotate(l);\n\treturn L_rotate(p);\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::RL_rotate(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt; *l &#x3D; p-&gt;right;\n\tp-&gt;right &#x3D; L_rotate(l);\n\treturn R_rotate(p);\n&#125;\n\ntemplate&lt;class T&gt;\nvoid AVLTree&lt;T&gt;::insert(const T&amp; el) &#123;\n\tinsert_(root, el);\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::insert_(AVLnode&lt;T&gt;* &amp;p, const T&amp; el) &#123;\n\tif (p &#x3D;&#x3D; nullptr) &#123;\n\t\tp &#x3D; new AVLnode&lt;T&gt;(el);\n\t\tif (p &#x3D;&#x3D; nullptr)\n\t\t\tcout &lt;&lt; &quot;failed to insert a new node&quot; &lt;&lt; endl;\n\t&#125;\n\telse if (el &lt; p-&gt;info) &#123;\n\t\tp-&gt;left &#x3D; insert_(p-&gt;left, el);\n\t\t&#x2F;&#x2F;回溯判断新树是否失衡\n\t\tif (GetHeight(p-&gt;left) - GetHeight(p-&gt;right) &gt; 1) &#123;\n\t\t\tif (el &lt; p-&gt;left-&gt;info) p &#x3D; L_rotate(p);\n\t\t\telse p &#x3D; LR_rotate(p);\n\t\t&#125;\n\t&#125;\n\telse if (el &gt; p-&gt;info) &#123;\n\t\tp-&gt;right &#x3D; insert_(p-&gt;right, el);\n\t\tif (GetHeight(p-&gt;right) - GetHeight(p-&gt;left) &gt; 1) &#123;\n\t\t\tif (el &gt; p-&gt;right-&gt;info) p &#x3D; R_rotate(p);\n\t\t\telse p &#x3D; RL_rotate(p);\n\t\t&#125;\n\t&#125;\n\telse cout &lt;&lt; &quot;this node is in the tree already!&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;更新节点高度\n\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\treturn p;\n&#125;\n\ntemplate&lt;class T&gt;\nvoid AVLTree&lt;T&gt;::remove(const T&amp; el) &#123;\n\t&#x2F;&#x2F;search接口与普通二叉树定义一样，返回指向该节点的指针\n\tAVLnode&lt;T&gt;* cur &#x3D; search(el);\n\tif (cur !&#x3D; nullptr)\n\t\troot &#x3D; remove_(root, cur);\n&#125;\n\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;* AVLTree&lt;T&gt;::remove_(AVLnode&lt;T&gt;* &amp;p, AVLnode&lt;T&gt;* cur) &#123;\n\tif (cur-&gt;info &lt; p-&gt;info) &#123;\n\t\tp-&gt;left &#x3D; remove_(p-&gt;left, cur);\n\t\tif (GetHeight(p-&gt;right) - GetHeight(p-&gt;left) &gt; 1) &#123;\n\t\t\tif (GetHeight(p-&gt;right-&gt;right) &gt; GetHeight(p-&gt;right-&gt;left))\n\t\t\t\tp &#x3D; R_rotate(p);\n\t\t\telse p &#x3D; RL_rotate(p);\n\t\t&#125;\n\t&#125;\n\telse if (cur-&gt;info &gt; p-&gt;info) &#123;\n\t\tp-&gt;right &#x3D; remove_(p-&gt;right, cur);\n\t\tif (GetHeight(p-&gt;left) - GetHeight(p-&gt;right) &gt; 1) &#123;\n\t\t\tif (GetHeight(p-&gt;left-&gt;left) &gt; GetHeight(p-&gt;left-&gt;right))\n\t\t\t\tp &#x3D; L_rotate(p);\n\t\t\telse p &#x3D; LR_rotate(p);\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;找到被删除节点的位置\n\telse &#123;\n\n\t\tif (p-&gt;left !&#x3D; nullptr &amp;&amp; p-&gt;right !&#x3D; nullptr) &#123;\n\t\t\tif (GetHeight(p-&gt;left) &gt; GetHeight(p-&gt;right)) &#123;\n\t\t\t\t&#x2F;&#x2F;maxleft返回指向左子树的最大值节点，这里类似于复制删除\n\t\t\t\tAVLnode&lt;T&gt;* tem &#x3D; maxleft(p-&gt;left);\n\t\t\t\tp-&gt;info &#x3D; tem-&gt;info;\n\t\t\t\t&#x2F;&#x2F;转换成删除另外一个节点\n\t\t\t\tremove_(p-&gt;left, tem);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\t&#x2F;&#x2F;minright返回右子树的最小值节点\n\t\t\t\tAVLnode&lt;T&gt;* tem &#x3D; minright(p-&gt;right);\n\t\t\t\tp-&gt;info &#x3D; tem-&gt;info;\n\t\t\t\tremove_(p-&gt;right, tem);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F;实际的删除操作发生在这里\n\t\t\tAVLnode&lt;T&gt;* tem &#x3D; p;\n\t\t\tp &#x3D; (p-&gt;left &#x3D;&#x3D; nullptr) ? p-&gt;right : p-&gt;left;\n\t\t\tdelete tem;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;更新高度，注意这里若p是空就不需要更新了，\n\t&#x2F;&#x2F;直接回溯到上一层递归更新高度即可\n\tif (p !&#x3D; nullptr)\n\t\tp-&gt;height &#x3D; max(GetHeight(p-&gt;left), GetHeight(p-&gt;right)) + 1;\n\treturn p;\n&#125;\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;*  AVLTree&lt;T&gt;::maxleft(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt;* cur &#x3D; p, *pre &#x3D; p;\n\twhile (cur !&#x3D; nullptr) &#123;\n\t\tpre &#x3D; cur;\n\t\tcur &#x3D; cur-&gt;right;\n\t&#125;\n\treturn pre;\n&#125;\n\n\ntemplate&lt;class T&gt;\nAVLnode&lt;T&gt;*  AVLTree&lt;T&gt;::minright(AVLnode&lt;T&gt;* p) &#123;\n\tAVLnode&lt;T&gt;* cur &#x3D; p, *pre &#x3D; p;\n\twhile (cur !&#x3D; nullptr) &#123;\n\t\tpre &#x3D; cur;\n\t\tcur &#x3D; cur-&gt;left;\n\t&#125;\n\treturn pre;\n&#125;\n\n\n\n\nb树定义B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： \n\n每个节点最多只有m个子节点。\n每个非叶子节点（除了根）具有至少⌈ m&#x2F;2⌉子节点。\n如果根不是叶节点，则根至少有两个子节点。\n具有k个子节点的非叶节点包含k -1个键。\n所有叶子都出现在同一水平，没有任何信息（高度一致）。\n\n性质根节点：\n2&lt;&#x3D; M &lt;&#x3D;m，M为子节点数量\n1&lt;&#x3D; K &lt;&#x3D;m-1,K为元素数量\n（m&#x2F;2）&lt;&#x3D; M &lt;&#x3D;m\nm&#x2F;2）-1&lt;&#x3D; K &lt;&#x3D;m-1\nm&#x2F;2为认为规定，防止树的高度过高\n操作插入在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。\n\n若该节点元素个数小于m-1，直接插入；\n若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；\n重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1；\n\n删除查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；\n删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；\n\n某结点中元素数目小于（m&#x2F;2）-1,(m&#x2F;2)向上取整，则需要看其某相邻兄弟结点是否丰满；\n如果丰满（结点中元素个数大于(m&#x2F;2)-1），则向父节点借一个元素来满足条件；\n如果其相邻兄弟都不丰满，即其结点数目等于(m&#x2F;2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；\n\n代码实现#pragma once\n#include&lt;iostream&gt;\nusing namespace std;\ntemplate&lt;class T&gt;\nclass CBTree\n&#123;\nprivate:\n\t&#x2F;&#x2F;m阶至多m个孩子，t度至多2t-1个关键字，即2t个孩子，t度 的B树就是 2t阶 的B树\n\tstatic const int M &#x3D; 4;                  &#x2F;&#x2F;B树的最小度数\n\tstatic const int KEY_MAX &#x3D; 2 * M - 1;        &#x2F;&#x2F;节点包含关键字的最大个数\n\tstatic const int KEY_MIN &#x3D; M - 1;          &#x2F;&#x2F;非根节点包含关键字的最小个数\n\tstatic const int CHILD_MAX &#x3D; KEY_MAX + 1;  &#x2F;&#x2F;孩子节点的最大个数\n\tstatic const int CHILD_MIN &#x3D; KEY_MIN + 1;  &#x2F;&#x2F;孩子节点的最小个数\n\tstruct Node\n\t&#123;\n\t\tbool isLeaf;             &#x2F;&#x2F;是否是叶子节点\n\t\tint keyNum;              &#x2F;&#x2F;节点包含的关键字数量\n\t\tT keyValue[KEY_MAX];     &#x2F;&#x2F;关键字的值数组\n\t\tNode *pChild[CHILD_MAX]; &#x2F;&#x2F;子树指针数组\n\n\t\tNode(bool b &#x3D; true, int n &#x3D; 0)\n\t\t\t:isLeaf(b), keyNum(n) &#123;&#125;\n\t&#125;;\npublic:\n\tCBTree()\n\t&#123;\n\t\tm_pRoot &#x3D; NULL;  &#x2F;&#x2F;创建一棵空的B树\n\t&#125;\n\n\t~CBTree()\n\t&#123;\n\t\tclear();\n\t&#125;\n\n\tbool insert(const T &amp;key)    &#x2F;&#x2F;向B数中插入新结点key\n\t&#123;\n\t\tif (contain(key))  &#x2F;&#x2F;检查该关键字是否已经存在\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tif (m_pRoot &#x3D;&#x3D; NULL)&#x2F;&#x2F;检查是否为空树\n\t\t\t&#123;\n\t\t\t\tm_pRoot &#x3D; new Node();\n\t\t\t&#125;\n\t\t\tif (m_pRoot-&gt;keyNum &#x3D;&#x3D; KEY_MAX) &#x2F;&#x2F;检查根节点是否已满\n\t\t\t&#123;\n\t\t\t\tNode *pNode &#x3D; new Node();  &#x2F;&#x2F;创建新的根节点\n\t\t\t\tpNode-&gt;isLeaf &#x3D; false;\n\t\t\t\tpNode-&gt;pChild[0] &#x3D; m_pRoot;\n\t\t\t\tsplitChild(pNode, 0, m_pRoot);\n\t\t\t\tm_pRoot &#x3D; pNode;  &#x2F;&#x2F;更新根节点指针\n\t\t\t&#125;\n\t\t\tinsertNonFull(m_pRoot, key);\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\tbool remove(const T &amp;key)    &#x2F;&#x2F;从B中删除结点key\n\t&#123;\n\t\tif (!search(m_pRoot, key))  &#x2F;&#x2F;不存在\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\tif (m_pRoot-&gt;keyNum &#x3D;&#x3D; 1)&#x2F;&#x2F;特殊情况处理\n\t\t&#123;\n\t\t\tif (m_pRoot-&gt;isLeaf)\n\t\t\t&#123;\n\t\t\t\tclear();\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tNode *pChild1 &#x3D; m_pRoot-&gt;pChild[0];\n\t\t\t\tNode *pChild2 &#x3D; m_pRoot-&gt;pChild[1];\n\t\t\t\tif (pChild1-&gt;keyNum &#x3D;&#x3D; KEY_MIN &amp;&amp; pChild2-&gt;keyNum &#x3D;&#x3D; KEY_MIN)\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(m_pRoot, 0);\n\t\t\t\t\tdeleteNode(m_pRoot);\n\t\t\t\t\tm_pRoot &#x3D; pChild1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\trecursive_remove(m_pRoot, key);\n\t\treturn true;\n\t&#125;\n\tvoid display()const &#x2F;&#x2F;打印树的关键字\n\t&#123;\n\t\tdisplayInConcavo(m_pRoot, KEY_MAX * 10);\n\t&#125;\n\tbool contain(const T &amp;key)const   &#x2F;&#x2F;检查该key是否存在于B树中\n\t&#123;\n\t\treturn search(m_pRoot, key);\n\t&#125;\n\tvoid clear()                      &#x2F;&#x2F;清空B树\n\t&#123;\n\t\trecursive_clear(m_pRoot);\n\t\tm_pRoot &#x3D; NULL;\n\t&#125;\nprivate:\n\t&#x2F;&#x2F;删除树\n\tvoid recursive_clear(Node *pNode)\n\t&#123;\n\t\tif (pNode !&#x3D; NULL)\n\t\t&#123;\n\t\t\tif (!pNode-&gt;isLeaf)\n\t\t\t&#123;\n\t\t\t\tfor (int i &#x3D; 0; i &lt;&#x3D; pNode-&gt;keyNum; ++i)\n\t\t\t\t\trecursive_clear(pNode-&gt;pChild[i]);\n\t\t\t&#125;\n\t\t\tdeleteNode(pNode);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;删除节点\n\tvoid deleteNode(Node *&amp;pNode)\n\t&#123;\n\t\tif (pNode !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete pNode;\n\t\t\tpNode &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;查找关键字\n\tbool search(Node *pNode, const T &amp;key)const\n\t&#123;\n\t\tif (pNode &#x3D;&#x3D; NULL)  &#x2F;&#x2F;检测节点指针是否为空，或该节点是否为叶子节点\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tint i;\n\t\t\tfor (i &#x3D; 0; i&lt;pNode-&gt;keyNum &amp;&amp; key&gt;*(pNode-&gt;keyValue + i); ++i)&#x2F;&#x2F;找到使key&lt;&#x3D;pNode-&gt;keyValue[i]成立的最小下标i\n\t\t\t&#123;\n\t\t\t&#125;\n\t\t\tif (i &lt; pNode-&gt;keyNum &amp;&amp; key &#x3D;&#x3D; pNode-&gt;keyValue[i])\n\t\t\t&#123;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tif (pNode-&gt;isLeaf)   &#x2F;&#x2F;检查该节点是否为叶子节点\n\t\t\t\t&#123;\n\t\t\t\t\treturn false;\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\treturn search(pNode-&gt;pChild[i], key);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;分裂子节点\n\tvoid splitChild(Node *pParent, int nChildIndex, Node *pChild)\n\t&#123;\n\t\t&#x2F;&#x2F;将pChild分裂成pLeftNode和pChild两个节点\n\t\t&#x2F;&#x2F;分裂后的右节点\n\t\t&#x2F;&#x2F;初始化右节点\n\t\tNode *pRightNode &#x3D; new Node();\n\t\tpRightNode-&gt;isLeaf &#x3D; pChild-&gt;isLeaf;\n\t\tpRightNode-&gt;keyNum &#x3D; KEY_MIN;\n\t\tint i;\n\t\t&#x2F;&#x2F;拷贝关键字的值\n\t\tfor (i &#x3D; 0; i &lt; KEY_MIN; ++i)\n\t\t&#123;\n\t\t\tpRightNode-&gt;keyValue[i] &#x3D; pChild-&gt;keyValue[i + CHILD_MIN];&#x2F;&#x2F;从i + CHILD_MIN开始拷贝，给左孩子留下最少CHILD_MIN个关键字\n\t\t&#125;\n\t\t&#x2F;&#x2F;如果不是叶子节点，拷贝孩子节点指针\n\t\tif (!pChild-&gt;isLeaf)  \n\t\t&#123;\n\t\t\tfor (i &#x3D; 0; i &lt; CHILD_MIN; ++i)\n\t\t\t&#123;\n\t\t\t\tpRightNode-&gt;pChild[i] &#x3D; pChild-&gt;pChild[i + CHILD_MIN];\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tpChild-&gt;keyNum &#x3D; KEY_MIN;  &#x2F;&#x2F;更新左子树的关键字个数\n\n\t\tfor (i &#x3D; pParent-&gt;keyNum; i &gt; nChildIndex; --i)&#x2F;&#x2F;将父节点中的nChildIndex后的所有关键字的值和子树指针向后移一位\n\t\t&#123;\n\t\t\tpParent-&gt;pChild[i + 1] &#x3D; pParent-&gt;pChild[i];\n\t\t\tpParent-&gt;keyValue[i] &#x3D; pParent-&gt;keyValue[i - 1];\n\t\t&#125;\n\t\t++pParent-&gt;keyNum;  &#x2F;&#x2F;更新父节点的关键字个数\n\t\tpParent-&gt;pChild[nChildIndex + 1] &#x3D; pRightNode;  &#x2F;&#x2F;存储右子树指针\n\t\tpParent-&gt;keyValue[nChildIndex] &#x3D; pChild-&gt;keyValue[KEY_MIN];&#x2F;&#x2F;把节点的中间值提到父节点\n\t&#125;\n\n\t&#x2F;&#x2F;在非满节点中插入关键字\n\tvoid insertNonFull(Node *pNode, const T &amp;key)\n\t&#123;\n\t\tint i &#x3D; pNode-&gt;keyNum;  &#x2F;&#x2F;获取节点内关键字个数\n\t\tif (pNode-&gt;isLeaf)      &#x2F;&#x2F;pNode是叶子节点\n\t\t&#123;\n\t\t\twhile (i &gt; 0 &amp;&amp; key &lt; pNode-&gt;keyValue[i - 1])   &#x2F;&#x2F;从后往前，查找关键字的插入位置\n\t\t\t&#123;\n\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pNode-&gt;keyValue[i - 1];  &#x2F;&#x2F;向后移位\n\t\t\t\t--i;\n\t\t\t&#125;\n\t\t\tpNode-&gt;keyValue[i] &#x3D; key;  &#x2F;&#x2F;插入关键字的值\n\t\t\t++pNode-&gt;keyNum; &#x2F;&#x2F;更新节点关键字的个数\n\t\t&#125;\n\t\telse&#x2F;&#x2F;pNode是内节点\n\t\t&#123;\n\t\t\twhile (i &gt; 0 &amp;&amp; key &lt; pNode-&gt;keyValue[i - 1])   &#x2F;&#x2F;从后往前，查找关键字的插入的子树\n\t\t\t\t--i;\n\t\t\tNode *pChild &#x3D; pNode-&gt;pChild[i];  &#x2F;&#x2F;目标子树结点指针 \n\t\t\tif (pChild-&gt;keyNum &#x3D;&#x3D; KEY_MAX)  &#x2F;&#x2F;子树节点已满\n\t\t\t&#123;\n\t\t\t\tsplitChild(pNode, i, pChild);&#x2F;&#x2F;分裂子树节点\n\t\t\t\tif (key &gt; pNode-&gt;keyValue[i])   &#x2F;&#x2F;确定目标子树\n\t\t\t\t\tpChild &#x3D; pNode-&gt;pChild[i + 1];\n\t\t\t&#125;\n\t\t\tinsertNonFull(pChild, key);  &#x2F;&#x2F;插入关键字到目标子树节点\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;用括号打印树\n\tvoid displayInConcavo(Node *pNode, int count)const\n\t&#123;\n\t\tif (pNode !&#x3D; NULL)\n\t\t&#123;\n\t\t\tint i, j;\n\t\t\tfor (i &#x3D; 0; i &lt; pNode-&gt;keyNum; ++i)\n\t\t\t&#123;\n\t\t\t\tif (!pNode-&gt;isLeaf)\n\t\t\t\t&#123;\n\t\t\t\t\tdisplayInConcavo(pNode-&gt;pChild[i], count - 2);\n\t\t\t\t&#125;\n\t\t\t\tfor (j &#x3D; count; j &gt;&#x3D; 0; --j)\n\t\t\t\t&#123;\n\t\t\t\t\tcout &lt;&lt; &quot;-&quot;;\n\t\t\t\t&#125;\n\t\t\t\tcout &lt;&lt; pNode-&gt;keyValue[i] &lt;&lt; endl;\n\t\t\t&#125;\n\t\t\tif (!pNode-&gt;isLeaf)\n\t\t\t&#123;\n\t\t\t\tdisplayInConcavo(pNode-&gt;pChild[i], count - 2);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;合并两个子节点\n\tvoid mergeChild(Node *pParent, int index)\n\t&#123;\n\t\tNode *pChild1 &#x3D; pParent-&gt;pChild[index];\n\t\tNode *pChild2 &#x3D; pParent-&gt;pChild[index + 1];\n\t\t&#x2F;&#x2F;将pChild2数据合并到pChild1\n\t\tpChild1-&gt;keyNum &#x3D; KEY_MAX;\n\t\tpChild1-&gt;keyValue[KEY_MIN] &#x3D; pParent-&gt;keyValue[index];&#x2F;&#x2F;将父节点index的值下移\n\t\tint i;\n\t\tfor (i &#x3D; 0; i &lt; KEY_MIN; ++i)\n\t\t&#123;\n\t\t\tpChild1-&gt;keyValue[i + KEY_MIN + 1] &#x3D; pChild2-&gt;keyValue[i];\n\t\t&#125;\n\t\tif (!pChild1-&gt;isLeaf)\n\t\t&#123;\n\t\t\tfor (i &#x3D; 0; i &lt; CHILD_MIN; ++i)\n\t\t\t&#123;\n\t\t\t\tpChild1-&gt;pChild[i + CHILD_MIN] &#x3D; pChild2-&gt;pChild[i];\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;父节点删除index的key，index后的往前移一位\n\t\t--pParent-&gt;keyNum;\n\t\tfor (i &#x3D; index; i &lt; pParent-&gt;keyNum; ++i)\n\t\t&#123;\n\t\t\tpParent-&gt;keyValue[i] &#x3D; pParent-&gt;keyValue[i + 1];\n\t\t\tpParent-&gt;pChild[i + 1] &#x3D; pParent-&gt;pChild[i + 2];\n\t\t&#125;\n\t\tdeleteNode(pChild2);  &#x2F;&#x2F;删除pChild2\n\t&#125;\n\n\t&#x2F;&#x2F;递归的删除关键字\n\tvoid recursive_remove(Node *pNode, const T &amp;key)\n\t&#123;\n\t\tint i &#x3D; 0;\n\t\twhile (i&lt;pNode-&gt;keyNum&amp;&amp;key&gt;pNode-&gt;keyValue[i])\n\t\t\t++i;\n\t\tif (i &lt; pNode-&gt;keyNum&amp;&amp;key &#x3D;&#x3D; pNode-&gt;keyValue[i])&#x2F;&#x2F;关键字key在节点pNode中\n\t\t&#123;\n\t\t\tif (pNode-&gt;isLeaf)&#x2F;&#x2F;pNode是个叶节点\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;从pNode中删除k\n\t\t\t\t--pNode-&gt;keyNum;\n\t\t\t\tfor (; i &lt; pNode-&gt;keyNum; ++i)\n\t\t\t\t&#123;\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pNode-&gt;keyValue[i + 1];\n\t\t\t\t&#125;\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t\telse&#x2F;&#x2F;pNode是个内节点\n\t\t\t&#123;\n\t\t\t\tNode *pChildPrev &#x3D; pNode-&gt;pChild[i];&#x2F;&#x2F;节点pNode中前于key的子节点\n\t\t\t\tNode *pChildNext &#x3D; pNode-&gt;pChild[i + 1];&#x2F;&#x2F;节点pNode中后于key的子节点\n\t\t\t\tif (pChildPrev-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;节点pChildPrev中至少包含CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\tT prevKey &#x3D; getPredecessor(pChildPrev); &#x2F;&#x2F;获取key的前驱关键字\n\t\t\t\t\trecursive_remove(pChildPrev, prevKey);\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; prevKey;     &#x2F;&#x2F;替换成key的前驱关键字\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t\telse if (pChildNext-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;节点pChildNext中至少包含CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\tT nextKey &#x3D; getSuccessor(pChildNext); &#x2F;&#x2F;获取key的后继关键字\n\t\t\t\t\trecursive_remove(pChildNext, nextKey);\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; nextKey;     &#x2F;&#x2F;替换成key的后继关键字\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t\telse&#x2F;&#x2F;节点pChildPrev和pChildNext中都只包含CHILD_MIN-1个关键字\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(pNode, i);\n\t\t\t\t\trecursive_remove(pChildPrev, key);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse&#x2F;&#x2F;关键字key不在节点pNode中\n\t\t&#123;\n\t\t\tNode *pChildNode &#x3D; pNode-&gt;pChild[i];&#x2F;&#x2F;包含key的子树根节点\n\t\t\tif (pChildNode-&gt;keyNum &#x3D;&#x3D; KEY_MIN)&#x2F;&#x2F;只有t-1个关键字\n\t\t\t&#123;\n\t\t\t\tNode *pLeft &#x3D; i &gt; 0 ? pNode-&gt;pChild[i - 1] : NULL;  &#x2F;&#x2F;左兄弟节点\n\t\t\t\tNode *pRight &#x3D; i &lt; pNode-&gt;keyNum ? pNode-&gt;pChild[i + 1] : NULL;&#x2F;&#x2F;右兄弟节点\n\t\t\t\tint j;\n\t\t\t\tif (pLeft&amp;&amp;pLeft-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;左兄弟节点至少有CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;父节点中i-1的关键字下移至pChildNode中\n\t\t\t\t\tfor (j &#x3D; pChildNode-&gt;keyNum; j &gt; 0; --j)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpChildNode-&gt;keyValue[j] &#x3D; pChildNode-&gt;keyValue[j - 1];\n\t\t\t\t\t&#125;\n\t\t\t\t\tpChildNode-&gt;keyValue[0] &#x3D; pNode-&gt;keyValue[i - 1];\n\n\t\t\t\t\tif (!pLeft-&gt;isLeaf)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tfor (j &#x3D; pChildNode-&gt;keyNum + 1; j &gt; 0; --j) &#x2F;&#x2F;pLeft节点中合适的子女指针移植到pChildNode中\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tpChildNode-&gt;pChild[j] &#x3D; pChildNode-&gt;pChild[j - 1];\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tpChildNode-&gt;pChild[0] &#x3D; pLeft-&gt;pChild[pLeft-&gt;keyNum];\n\t\t\t\t\t&#125;\n\t\t\t\t\t++pChildNode-&gt;keyNum;\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pLeft-&gt;keyValue[pLeft-&gt;keyNum - 1];&#x2F;&#x2F;pLeft节点中的最大关键字上升到pNode中\n\t\t\t\t\t--pLeft-&gt;keyNum;\n\t\t\t\t&#125;\n\t\t\t\telse if (pRight&amp;&amp;pRight-&gt;keyNum &gt;&#x3D; CHILD_MIN)&#x2F;&#x2F;右兄弟节点至少有CHILD_MIN个关键字\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;父节点中i的关键字下移至pChildNode中\n\t\t\t\t\tpChildNode-&gt;keyValue[pChildNode-&gt;keyNum] &#x3D; pNode-&gt;keyValue[i];\n\t\t\t\t\t++pChildNode-&gt;keyNum;\n\t\t\t\t\tpNode-&gt;keyValue[i] &#x3D; pRight-&gt;keyValue[0];&#x2F;&#x2F;pRight节点中的最小关键字上升到pNode中\n\t\t\t\t\t--pRight-&gt;keyNum;\n\t\t\t\t\tfor (j &#x3D; 0; j &lt; pRight-&gt;keyNum; ++j)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpRight-&gt;keyValue[j] &#x3D; pRight-&gt;keyValue[j + 1];\n\t\t\t\t\t&#125;\n\t\t\t\t\tif (!pRight-&gt;isLeaf)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpChildNode-&gt;pChild[pChildNode-&gt;keyNum] &#x3D; pRight-&gt;pChild[0];&#x2F;&#x2F;pRight节点中合适的子女指针移植到pChildNode中\n\t\t\t\t\t\tfor (j &#x3D; 0; j &lt;&#x3D; pRight-&gt;keyNum; ++j)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tpRight-&gt;pChild[j] &#x3D; pRight-&gt;pChild[j + 1];\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;左右兄弟节点都只包含CHILD_MIN-1个节点\n\t\t\t\telse if (pLeft)&#x2F;&#x2F;与左兄弟合并\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(pNode, i - 1);\n\t\t\t\t\tpChildNode &#x3D; pLeft;\n\t\t\t\t&#125;\n\t\t\t\telse if (pRight)&#x2F;&#x2F;与右兄弟合并\n\t\t\t\t&#123;\n\t\t\t\t\tmergeChild(pNode, i);\n\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\trecursive_remove(pChildNode, key);\n\t\t&#125;\n\t&#125;\n\n\tT getPredecessor(Node *pNode)&#x2F;&#x2F;找到前驱关键字\n\t&#123;\n\t\twhile (!pNode-&gt;isLeaf)\n\t\t&#123;\n\t\t\tpNode &#x3D; pNode-&gt;pChild[pNode-&gt;keyNum];\n\t\t&#125;\n\t\treturn pNode-&gt;keyValue[pNode-&gt;keyNum - 1];\n\t&#125;\n\n\tT getSuccessor(Node *pNode)&#x2F;&#x2F;找到后继关键字\n\t&#123;\n\t\twhile (!pNode-&gt;isLeaf)\n\t\t&#123;\n\t\t\tpNode &#x3D; pNode-&gt;pChild[0];\n\t\t&#125;\n\t\treturn pNode-&gt;keyValue[0];\n\t&#125;\n\nprivate:\n\tNode * m_pRoot;  &#x2F;&#x2F;B树的根节点\n&#125;;\n\n\n\n看看就好\nb+树2-3树红黑树散列表排序插入排序将序列分成三部分：有序，待排元素，未排\nvoid insertSort(vector&lt;int&gt;&amp;nums)\n&#123;\n\tint len &#x3D;nums.size();\t\t\n\tint dummy &#x3D; 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;哨兵数，存放待排元素\n\tfor (int i &#x3D; 1; i &lt;len; i++)\n\t&#123;\n\t\tif (nums[i] &lt; nums[i - 1])\n\t\t&#123;\n\t\t\tdummy &#x3D; nums[i];\n\t\t\tfor (int j &#x3D; i - 1; dummy &lt; nums[j]; j--)\n\t\t\t&#123;\n\t\t\t\tnums[j + 1] &#x3D; nums[j];\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;后移\n\t\t\t&#125;\n\t\t\tnums[j + 1] &#x3D; dummy;\n\t\t&#125;\n\t&#125;\n&#125;\n\n时间复杂度：On^2\n空间复杂度：O1\n稳定排序\n适用情景：顺序存储与链式存储的线性表\n折半插入排序：定位元素位置的时候二分查找\n希尔排序冒泡排序void BubbleSort(vector&lt;int&gt;&amp;array)\n&#123;\n\tint len &#x3D; array.size();\n\t&#x2F;&#x2F;每一轮交换都能将一个最小的元素放到前面\n\tfor (int i &#x3D; 0; i &lt; len-1; i++)\n\t&#123;\n\t\tbool flag &#x3D; false;\n\t\tfor (int j &#x3D; len - 1; j &gt; i; j--)\n\t\t&#123;\n\t\t\tif (array[j - 1] &gt; array[j])\n\t\t\t&#123;\n\t\t\t\tswap(array[j - 1], array[j]);\n\t\t\t\tflag &#x3D; true;\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;如果本轮没有交换，则已经有序，后面不用再排\n\t\tif (!flag)\n\t\t&#123;\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n&#125;\n\n时间复杂度：On^2\n空间复杂度：O1\n稳定排序\n快速排序#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nint partition(vector&lt;int&gt;&amp;nums,int l,int r)\n&#123;\n\tint pivot &#x3D; nums[l];\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;基准元素，序列被划分成两部分，在其左边的小于基准元素，在右边的大于基准元素\n\twhile (l &lt; r)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;双指针\n\t&#123;\n\t\twhile (l &lt; r&amp;&amp;nums[r] &gt;&#x3D; pivot)\n\t\t&#123;\n\t\t\tr--;\n\t\t&#125;\n\t\tnums[l] &#x3D; nums[r];\n\t\twhile (l &lt; r&amp;&amp;nums[l] &lt;&#x3D; pivot)\n\t\t&#123;\n\t\t\tl++;\n\t\t&#125;\n\t\tnums[r] &#x3D; nums[l];\n\t&#125;\n\tnums[l] &#x3D; pivot;\n\treturn l;\n&#125;\n\nvoid quickSort(vector&lt;int&gt;&amp;nums,int l,int r)\n&#123;\n\tif (l &lt; r)\n\t&#123;\n\t\tint pivotpos &#x3D; partition(nums, l, r);\t\t\t\t\t\t\t\t&#x2F;&#x2F;递归切块排序\n\t\tquickSort(nums, l, pivotpos-1);\n\t\tquickSort(nums, pivotpos + 1, r);\n\t&#125;\n&#125;\n\n时间复杂度：Onlogn\n空间复杂度：O1\n不稳定排序\n选择排序void SelectSort(vector&lt;int&gt;&amp;array)\n&#123;\n\tint len &#x3D; array.size();\n\tfor (int i &#x3D; 0; i &lt; len - 1; i++)\n\t&#123;\n\t\tint min&#x3D; i;\n\t\tfor (int j &#x3D; i + 1; j &lt; len; j++)\n\t\t&#123;\n\t\t\tif (array[j] &lt; array[min])min &#x3D; j;\n\t\t&#125;\n\t\tif (min !&#x3D; i)\n\t\t&#123;\n\t\t\tswap(array[i], array[min]);\n\t\t&#125;\n\t&#125;\n&#125;\n\n时间复杂度：On^2\n空间复杂度：O1\n不稳定排序\n堆排序#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvoid heapadjust(vector&lt;int&gt;&amp;store, int k,int len)\n&#123;\n\tstore[0] &#x3D; store[len];\n\tfor (int i &#x3D; 2 * k; i &lt;&#x3D; len; i*&#x3D;2)\n\t&#123;\n\t\tif (i &lt; len&amp;&amp;store[i] &lt; store[i + 1])\n\t\t\ti++;\n\t\tif (store[0] &gt; store[i])\n\t\t\tbreak;\n\t\telse\n\t\t&#123;\n\t\t\tstore[k] &#x3D; store[i];\n\t\t\tk &#x3D; i;\n\t\t&#125;\n\t&#125;\n\tstore[k] &#x3D; store[0];\n&#125;\n\nvoid buildMaxHeap(vector&lt;int&gt;&amp;store,int len)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len &#x2F; 2; i &gt; 0; i--)\n\t&#123;\n\t\theapadjust(store, i);\n\t&#125;\n&#125;\n\nvoid heapSort(vector&lt;int&gt;&amp;store)\n&#123;\n\tint len &#x3D; store.size();\n\tfor (int i &#x3D; len; i &gt;1; i--)\n\t&#123;\n\t\tswap(store[i], store[1]);\n\t\theapadjust(store, 1,i-1);\n\t&#125;\n&#125;\n\n时间复杂度：Onlogn\n空间复杂度：O1\n不稳定排序\n归并排序void Merge(vector&lt;int&gt;&amp;array, int low, int mid, int high)\n&#123;\n\tvector&lt;int&gt;helper(array);\n\t&#x2F;&#x2F;将原数组分成两部分，i指向辅助数组第一部分，j指向辅助数组第二部分，k指向原数组，双指针填充原数组\n\tint i,j,k;\n\tfor (i &#x3D; low, j &#x3D; mid + 1, k &#x3D; i; i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high; k++)\n\t&#123;\n\t\tif (helper[i] &lt;&#x3D; helper[j])\n\t\t&#123;\n\t\t\tarray[k] &#x3D; helper[i++];\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tarray[k] &#x3D; helper[j++];\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;将未检测完的表填入\n\twhile (i &lt;&#x3D; mid)\n\t&#123;\n\t\tarray[k++] &#x3D; helper[i++];\n\t&#125;\n\twhile (j &lt;&#x3D; high)\n\t&#123;\n\t\tarray[k++] &#x3D; helper[j++];\n\t&#125;\n&#125;\n\nvoid MergeSort(vector&lt;int&gt;&amp;array, int low, int high)\n&#123;\n\tif (low &lt; high)\n\t&#123;\n\t\tint mid &#x3D; (low + high) &#x2F; 2;\n\t\tMergeSort(array, low, mid);\n\t\tMergeSort(array, mid+1, high);\n\t\tMerge(array, low, mid,high);\n\t&#125;\n&#125;\n\n时间复杂度：Onlogn\n空间复杂度：On\n稳定排序\n基数排序算法核心思想图快速建图\n\n\n\n最小生成树kruskal\n对边贪心\n1选一条最短的边加入集合\n2在剩余的边中选最短且不会形成回路的边加入集合\n3重复n-1次\nprim\n对点贪心\n1任取一点加入集合T\n2选择不在T中的且与T中点最近的点加入集合\n3重复n-1次\n例题kruskal\nclass UnionFind\n&#123;\nprivate:\n    vector&lt;int&gt;parent;\npublic:\n    UnionFind(int n)\n    &#123;\n        parent.resize(n+1);\n        iota(parent.begin(),parent.end(),0);\n    &#125;\n\n    int find(int index)\n    &#123;\n        if(parent[index]&#x3D;&#x3D;index)\n        &#123;\n            return index;\n        &#125;\n        parent[index]&#x3D;find(parent[index]);\n        return parent[index];\n    &#125;\n\n    void Union(int m,int n)\n    &#123;\n        parent[find(m)]&#x3D;find(n);\n    &#125;\n\n&#125;;\n\nclass Solution &#123;\npublic:\n\n    int minimumCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) &#123;\n        &#x2F;&#x2F;对边排序\n        sort(connections.begin(),connections.end(),[](const std::vector&lt;int&gt;&amp; a, const std::vector&lt;int&gt;&amp; b) &#123;\n  return a[2] &lt; b[2];\n&#125;);\n\t\t\n        int m&#x3D;connections.size();\n        UnionFind uf(n);\n        int answer&#x3D;connections[0][2];\n        uf.Union(connections[0][0],connections[0][1]);\n        int cnt&#x3D;1;\n        for(int i&#x3D;1;i&lt;n-1;)\n        &#123;\n            if(cnt&#x3D;&#x3D;m)\n            &#123;\n                return -1;\n            &#125;\n            &#x2F;&#x2F;！！！\n            if(uf.find(connections[cnt][0])!&#x3D;uf.find(connections[cnt][1]))\n            &#123;\n                answer+&#x3D;connections[cnt][2];\n                uf.Union(connections[cnt][0],connections[cnt][1]);\n                i++;\n            &#125;\n            cnt++;\n        &#125;\n\n    return answer;\n\n    &#125;\n&#125;;\n\n最短路径Dijkstra\n1 从不在集合S中的顶点选择Dv最小的顶点v，将其放入集 合S；\n2 考察v的不在S中的邻接顶点w，若Dv+weight(v,w) &lt; Dw， 则更新Dw，使Dw&#x3D;Dv+weight(v,w) .\n3 重复① ② ，直至所有顶点都放入集合S。\n\n\n","slug":"数据结构","date":"2022-12-27T09:55:32.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-12-27T03:45:53.202Z","categories_index":"","tags_index":"","author_index":"Aurora"}]